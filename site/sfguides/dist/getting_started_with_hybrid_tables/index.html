
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Getting Started with Hybrid Tables</title>

  
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5Q8R2G');</script>
  

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-08H27EW14N"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-08H27EW14N');
</script>

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q8R2G"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  
  <google-codelab-analytics gaid="UA-41491190-9"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="getting_started_with_hybrid_tables"
                  title="Getting Started with Hybrid Tables"
                  environment="web"
                  feedback-link="https://github.com/Snowflake-Labs/sfguides/issues">
    
      <google-codelab-step label="Overview" duration="5">
        <h2 is-upgraded>Hybrid Tables</h2>
<p>A <a href="https://docs.snowflake.com/en/user-guide/tables-hybrid" target="_blank">hybrid table</a> is a Snowflake table type that is optimized for hybrid transactional and operational workloads that require low latency and high throughput on small random point reads and writes. A hybrid table supports unique and referential integrity constraint enforcement that is critical for transactional workloads. You can use a hybrid table along with other Snowflake tables and features to power <a href="https://www.snowflake.com/en/data-cloud/workloads/unistore/" target="_blank">Unistore workloads</a> that bring transactional and analytical data together in a single platform.</p>
<p>Use cases that may benefit from hybrid tables include:</p>
<ul>
<li>Build a cohort for a targeted marketing campaign through an interactive user interface.</li>
<li>Maintain a central workflow state to coordinate large parallel data transformation pipelines.</li>
<li>Serve a precomputed promotion treatment for users who are visiting your website or mobile app.</li>
</ul>
<h2 is-upgraded>Architecture</h2>
<p>Hybrid tables are integrated seamlessly into the existing Snowflake architecture. Customers connect to the same Snowflake database service. Queries are compiled and optimized in the cloud services layer and executed in the same query engine in virtual warehouses. This provides several key benefits:</p>
<ul>
<li>Snowflake platform features, such as data governance, work with hybrid tables out of the box.</li>
<li>You can run hybrid workloads mixing operational and analytical queries.</li>
<li>You can join hybrid tables with other Snowflake tables and the query executes natively and efficiently in the same query engine. No federation is required.</li>
<li>You can execute an atomic transaction across hybrid tables and other Snowflake tables. There is no need to orchestrate your own two-phase commit.</li>
</ul>
<p class="image-container"><img alt="Architecture" src="img/4bed6d48840e07c5.png"></p>
<p>Hybrid tables leverage a row store as the primary data store to provide excellent operational query performance. When you write to a hybrid table, the data is written directly into the rowstore. Data is asynchronously copied into object storage in order to provide better performance and workload isolation for large scans without impacting your ongoing operational workloads. Some data may also be cached in columnar format on your warehouse in order to provide better performance on analytical queries. You simply execute SQL statements against the logical hybrid table and Snowflake&#39;s query optimizer decides where to read data from in order to provide the best performance. You get one consistent view of your data without needing to worry about the underlying infrastructure.</p>
<h2 is-upgraded>What You Will Learn</h2>
<ul>
<li>The basics of hybrid tables</li>
<li>How to create and use hybrid tables</li>
<li>The advantages of hybrid tables over standard tables</li>
<li>Hybrid table unique characteristics like Indexes, primary keys, unique and foreign keys</li>
</ul>
<h2 is-upgraded>Prerequisites</h2>
<ul>
<li>Familiarity with the Snowflake Snowsight interface</li>
<li>Familiarity with SQL</li>
<li>Snowflake non-trial account with Hybrid Tables enabled</li>
<li>Account admin credentials which you should use to execute the quickstart</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Setup" duration="5">
        <p>In this part of the step, we will setup our Snowflake account, create new worksheets, role, database structures, create a Virtual Warehouse and create two hybrid tables and one standard table that we will use in this step.</p>
<h2 is-upgraded>Step 2.1 Creating a Worksheet</h2>
<p>Within Worksheets, click the &#34;+&#34; button in the top-right corner of Snowsight and choose &#34;SQL Worksheet&#34;</p>
<p class="image-container"><img alt="Create New SQL Worksheet" src="img/b82a768bfd09f1bf.png"></p>
<p>Rename the Worksheet by clicking on the auto-generated Timestamp name and inputting &#34;Hybrid Table - QuickStart&#34;</p>
<h2 is-upgraded>Step 2.2 Setup</h2>
<h3 is-upgraded>Create Objects</h3>
<p>Next we will create HYBRID_QUICKSTART_ROLE role, HYBRID_QUICKSTART_WH warehouse and HYBRID_QUICKSTART_DB database.</p>
<pre><code language="language-sql" class="language-sql">USE ROLE ACCOUNTADMIN;
-- Create role HYBRID_QUICKSTART_ROLE
CREATE OR REPLACE ROLE HYBRID_QUICKSTART_ROLE;
GRANT ROLE HYBRID_QUICKSTART_ROLE TO ROLE ACCOUNTADMIN ;

-- Create HYBRID_QUICKSTART_WH warehouse
CREATE OR REPLACE WAREHOUSE HYBRID_QUICKSTART_WH WAREHOUSE_SIZE = XSMALL, AUTO_SUSPEND = 300, AUTO_RESUME= TRUE;
GRANT OWNERSHIP ON WAREHOUSE HYBRID_QUICKSTART_WH TO ROLE HYBRID_QUICKSTART_ROLE;
GRANT CREATE DATABASE ON ACCOUNT TO ROLE HYBRID_QUICKSTART_ROLE;

-- Use role and create HYBRID_QUICKSTART_DB database and schema.
CREATE OR REPLACE DATABASE HYBRID_QUICKSTART_DB;
GRANT OWNERSHIP ON DATABASE HYBRID_QUICKSTART_DB TO ROLE HYBRID_QUICKSTART_ROLE;
CREATE OR REPLACE SCHEMA DATA;
GRANT OWNERSHIP ON SCHEMA HYBRID_QUICKSTART_DB.DATA TO ROLE HYBRID_QUICKSTART_ROLE;

-- Use role
USE ROLE HYBRID_QUICKSTART_ROLE;

-- Set step context use HYBRID_DB_USER_(USER_NUMBER) database and DATA schema
USE DATABASE HYBRID_QUICKSTART_DB;
USE SCHEMA DATA;
</code></pre>
<h3 is-upgraded>Create Tables and Bulk Load Data</h3>
<p>In this quickstart, we will use Tasty Bytes Snowflake fictional food truck business data to simulate a data serving use case where we would like to serve data to our applications.</p>
<p>We will create three tables:</p>
<ul>
<li>ORDER_HEADER Hybrid table -  This  table stores order metadata such as TRUCK_ID, CUSTOMER_ID, ORDER_AMOUNT, etc.</li>
<li>TRUCK Hybrid table -  This table stores truck metadata such as TRUCK_ID,FRANCHISE_ID,MENU_TYPE_ID, etc.</li>
<li>TRUCK_HISTORY standard table -  This table will store historical TRUCK information, enabling you to track changes over time.</li>
</ul>
<p>You may bulk load data into hybrid tables by copying from a data stage or other tables (that is, using CTAS, COPY, or INSERT INTO ... SELECT). It is strongly recommended to bulk load data into a hybrid table using a CREATE TABLE ... AS SELECT statement, as there are several optimizations which can only be applied to a data load as part of table creation. Bulk loading via INSERT or COPY is supported, but data loading is slower compared to CTAS, which could be 10 times faster, for large amounts of data and queries against freshly loaded data will be slower as well. You need to define all keys, indexes, and constraints at the creation of a hybrid table.</p>
<p>First we have to create a <a href="https://docs.snowflake.com/en/sql-reference/sql/create-file-format" target="_blank">FILE FORMAT</a> that describes a set of staged data to access or load into Snowflake tables and a <a href="https://docs.snowflake.com/en/user-guide/data-load-overview" target="_blank">STAGE</a> which is a Snowflake object that points to a cloud storage location Snowflake can access to both ingest and query data. In this step the data is stored in a publicly accessible AWS S3 bucket which we are referencing when creating the Stage object.</p>
<pre><code language="language-sql" class="language-sql">-- Create a CSV file format named CSV_FORMAT
CREATE OR REPLACE FILE FORMAT CSV_FORMAT TYPE = csv field_delimiter = &#39;,&#39; skip_header = 1 null_if = (&#39;NULL&#39;, &#39;null&#39;) empty_field_as_null = true;
-- Create stage for loading orders data
CREATE OR REPLACE STAGE FROSTBYTE_TASTY_BYTES_STAGE URL = &#39;s3://sfquickstarts/hybrid_table_guide&#39; FILE_FORMAT = CSV_FORMAT;
</code></pre>
<p>Once we&#39;ve created the stage lets view using <a href="https://docs.snowflake.com/en/sql-reference/sql/list?utm_source=snowscope&utm_medium=serp&utm_term=LIST+%40" target="_blank">LIST</a> statement all the files in FROSTBYTE_TASTY_BYTES_STAGE named stage:</p>
<pre><code language="language-sql" class="language-sql">-- List all the files in FROSTBYTE_TASTY_BYTES_STAGE named stage:
list @FROSTBYTE_TASTY_BYTES_STAGE;
</code></pre>
<p>The statement should return two records: one for the ‘TRUCK.csv&#39; file and the second for the ‘ORDER_HEADER.csv&#39; file.</p>
<p>Once we&#39;ve created the Stage which points to where the data resides in cloud storage we can simply load the data using CTAS statement into our TRUCK table. The first DDL will create a hybrid table TRUCK using CREATE TABLE ... AS SELECT statement. Note the primary key constraint on the TRUCK_ID column. The second DDL will create a standard table TRUCK_HISTORY using CREATE TABLE ... AS SELECT statement.</p>
<pre><code language="language-sql" class="language-sql">-- current time step
SET CURRENT_TIMESTAMP = CURRENT_TIMESTAMP();

-- The first DDL will create TRUCK hybrid table using CREATE TABLE ... AS SELECT statement.
CREATE OR REPLACE HYBRID TABLE TRUCK (
	TRUCK_ID NUMBER(38,0) NOT NULL,
	MENU_TYPE_ID NUMBER(38,0),
	PRIMARY_CITY VARCHAR(16777216),
	REGION VARCHAR(16777216),
	ISO_REGION VARCHAR(16777216),
	COUNTRY VARCHAR(16777216),
	ISO_COUNTRY_CODE VARCHAR(16777216),
	FRANCHISE_FLAG NUMBER(38,0),
	YEAR NUMBER(38,0),
	MAKE VARCHAR(16777216),
	MODEL VARCHAR(16777216),
	EV_FLAG NUMBER(38,0),
	FRANCHISE_ID NUMBER(38,0),
	TRUCK_OPENING_DATE DATE,
    	TRUCK_EMAIL VARCHAR NOT NULL UNIQUE,
    	RECORD_START_TIME TIMESTAMP,
	primary key (TRUCK_ID) 
	)
	AS
	SELECT 
	t.$1 AS TRUCK_ID, 
	t.$2 AS MENU_TYPE_ID,
	t.$3 AS PRIMARY_CITY,
	t.$4 AS REGION,
	t.$5 AS ISO_REGION,
	t.$6 AS COUNTRY,
	t.$7 AS ISO_COUNTRY_CODE,
	t.$8 AS FRANCHISE_FLAG,
	t.$9 AS YEAR,
	t.$10 AS MAKE,
	t.$11 AS MODEL,
	t.$12 AS EV_FLAG,
	t.$13 AS FRANCHISE_ID,
	t.$14 AS TRUCK_OPENING_DATE,
	CONCAT(TRUCK_ID, &#39;_truck@email.com&#39;) TRUCK_EMAIL,
    	$CURRENT_TIMESTAMP AS RECORD_START_TIME
	FROM @FROSTBYTE_TASTY_BYTES_STAGE (pattern=&gt;&#39;.*TRUCK.csv&#39;) t;

-- The second DDL will create TRUCK_HISTORY standard table using CREATE TABLE ... AS SELECT statement.
CREATE OR REPLACE TABLE TRUCK_HISTORY (
	TRUCK_ID NUMBER(38,0) NOT NULL,
	MENU_TYPE_ID NUMBER(38,0),
	PRIMARY_CITY VARCHAR(16777216),
	REGION VARCHAR(16777216),
	ISO_REGION VARCHAR(16777216),
	COUNTRY VARCHAR(16777216),
	ISO_COUNTRY_CODE VARCHAR(16777216),
	FRANCHISE_FLAG NUMBER(38,0),
	YEAR NUMBER(38,0),
	MAKE VARCHAR(16777216),
	MODEL VARCHAR(16777216),
	EV_FLAG NUMBER(38,0),
	FRANCHISE_ID NUMBER(38,0),
	TRUCK_OPENING_DATE DATE,
    	TRUCK_EMAIL VARCHAR NOT NULL UNIQUE,
    	RECORD_START_TIME TIMESTAMP,
    	RECORD_END_TIME TIMESTAMP,
	primary key (TRUCK_ID) 
	)
	AS
	SELECT 
	t.$1 AS TRUCK_ID, 
	t.$2 AS MENU_TYPE_ID,
	t.$3 AS PRIMARY_CITY,
	t.$4 AS REGION,
	t.$5 AS ISO_REGION,
	t.$6 AS COUNTRY,
	t.$7 AS ISO_COUNTRY_CODE,
	t.$8 AS FRANCHISE_FLAG,
	t.$9 AS YEAR,
	t.$10 AS MAKE,
	t.$11 AS MODEL,
	t.$12 AS EV_FLAG,
	t.$13 AS FRANCHISE_ID,
	t.$14 AS TRUCK_OPENING_DATE,
	CONCAT(TRUCK_ID, &#39;_truck@email.com&#39;) TRUCK_EMAIL,
	$CURRENT_TIMESTAMP AS RECORD_START_TIME,
	NULL AS RECORD_END_TIME
	FROM @FROSTBYTE_TASTY_BYTES_STAGE (pattern=&gt;&#39;.*TRUCK.csv&#39;) t;
</code></pre>
<p>This DDL will create the structure for the ORDER_HEADER hybrid table. Note the following:</p>
<ul>
<li>Primary key constraint on ORDER_ID column</li>
<li>Foreign key references constraints on column TRUCK_ID from table TRUCK</li>
<li>secondary indexes on column ORDER_TS</li>
</ul>
<pre><code language="language-sql" class="language-sql">-- Creates or replace ORDER_HEADER table
CREATE OR REPLACE HYBRID TABLE ORDER_HEADER (
	ORDER_ID NUMBER(38,0) NOT NULL,
	TRUCK_ID NUMBER(38,0),
	LOCATION_ID NUMBER(19,0),
	CUSTOMER_ID NUMBER(38,0),
	DISCOUNT_ID FLOAT,
	SHIFT_ID NUMBER(38,0),
	SHIFT_START_TIME TIME(9),
	SHIFT_END_TIME TIME(9),
	ORDER_CHANNEL VARCHAR(16777216),
	ORDER_TS TIMESTAMP_NTZ(9),
	SERVED_TS VARCHAR(16777216),
	ORDER_CURRENCY VARCHAR(3),
	ORDER_AMOUNT NUMBER(38,4),
	ORDER_TAX_AMOUNT VARCHAR(16777216),
	ORDER_DISCOUNT_AMOUNT VARCHAR(16777216),
	ORDER_TOTAL NUMBER(38,4),
	ORDER_STATUS VARCHAR(16777216) DEFAULT &#39;INQUEUE&#39;,
	primary key (ORDER_ID),
	foreign key (TRUCK_ID) references TRUCK(TRUCK_ID) ,
	index IDX01_ORDER_TS(ORDER_TS)
);
</code></pre>
<p>This DML will insert data into table ORDER_HEADER using INSERT INTO ... SELECT statement</p>
<pre><code language="language-sql" class="language-sql">-- This DML will insert data into table ORDER_HEADER using INSERT INTO ... SELECT statement
insert into ORDER_HEADER (
	ORDER_ID,
	TRUCK_ID,
	LOCATION_ID,
	CUSTOMER_ID,
	DISCOUNT_ID,
	SHIFT_ID,
	SHIFT_START_TIME,
	SHIFT_END_TIME,
	ORDER_CHANNEL,
	ORDER_TS,
	SERVED_TS,
	ORDER_CURRENCY,
	ORDER_AMOUNT,
	ORDER_TAX_AMOUNT,
	ORDER_DISCOUNT_AMOUNT,
	ORDER_TOTAL,
	ORDER_STATUS)
	SELECT
	t.$1 AS ORDER_ID,
	t.$2 AS TRUCK_ID,
	t.$3 AS LOCATION_ID,
	t.$4 AS CUSTOMER_ID,
	t.$5 AS DISCOUNT_ID,
	t.$6 AS SHIFT_ID,
	t.$7 AS SHIFT_START_TIME,
	t.$8 AS SHIFT_END_TIME,
	t.$9 AS ORDER_CHANNEL,
	t.$10 AS ORDER_TS,
	t.$11 AS SERVED_TS,
	t.$12 AS ORDER_CURRENCY,
	t.$13 AS ORDER_AMOUNT,
	t.$14 AS ORDER_TAX_AMOUNT,
	t.$15 AS ORDER_DISCOUNT_AMOUNT,
	t.$16 AS ORDER_TOTAL,
	&#39;&#39; as ORDER_STATUS 
	FROM @FROSTBYTE_TASTY_BYTES_STAGE (pattern=&gt;&#39;.*ORDER_HEADER.csv&#39;) t;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Explore Data" duration="3">
        <p>In the previous Setup step we created HYBRID_QUICKSTART_ROLE role, HYBRID_QUICKSTART_WH warehouse, HYBRID_QUICKSTART_DB database and DATA schema. Let&#39;s use them.</p>
<pre><code language="language-sql" class="language-sql">-- Step 3
-- Set step context
USE ROLE HYBRID_QUICKSTART_ROLE;
USE WAREHOUSE HYBRID_QUICKSTART_WH;
USE DATABASE HYBRID_QUICKSTART_DB;
USE SCHEMA DATA;
</code></pre>
<p>We also created and loaded data into the TRUCK and ORDER_HEADER hybrid tables. Now we can run a few queries and review some information to get familiar with it.</p>
<p>View tables properties and metadata.</p>
<pre><code language="language-sql" class="language-sql">SHOW TABLES LIKE &#39;%TRUCK%&#39;;
SHOW TABLES LIKE &#39;%ORDER_HEADER%&#39;;
</code></pre>
<p>Display information about the columns in the table. Note the primary key and unique key columns.</p>
<pre><code language="language-sql" class="language-sql">--Describe the columns in the table TRUCK
DESC TABLE TRUCK;
--Describe the columns in the table ORDER_HEADER
DESC TABLE ORDER_HEADER;
</code></pre>
<p>Lists the hybird tables for which you have access privileges.</p>
<pre><code language="language-sql" class="language-sql">--Show all HYBRID tables
SHOW HYBRID TABLES;
</code></pre>
<p>List all the indexes in your account for which you have access privileges. Note the value of the is_unique column: for the PRIMARY KEY the value is Y and for the index the value is N.</p>
<pre><code language="language-sql" class="language-sql">--Show all HYBRID tables indexes
SHOW INDEXES;
</code></pre>
<p>Look at a sample of the tables.</p>
<pre><code language="language-sql" class="language-sql">-- Simple query to look at 10 rows of data from table TRUCK
select * from TRUCK limit 10;
-- Simple query to look at 10 rows of data from table TRUCK_HISTORY
select * from TRUCK_HISTORY limit 10;
-- Simple query to look at 10 rows of data from table ORDER_HEADER
select * from ORDER_HEADER limit 10;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Unique and Foreign Keys Constraints" duration="5">
        <p>In this part of the step, we will test Unique and Foreign Keys Constraints.</p>
<h2 is-upgraded>Step 4.1 Unique Constraints</h2>
<p>In this step, we will test Unique Constraint which ensures that all values in a column are different. In table TRUCK that we created in the Setup step we defined column TRUCK_EMAIL as NOT NULL and UNIQUE.</p>
<p>Display information about the columns in the table.</p>
<pre><code language="language-sql" class="language-sql">-- Step 4
-- Set step context
USE ROLE HYBRID_QUICKSTART_ROLE;
USE WAREHOUSE HYBRID_QUICKSTART_WH;
USE DATABASE HYBRID_QUICKSTART_DB;
USE SCHEMA DATA;
-- Describe the columns in the table TRUCK
-- Note the unique key value for the TRUCK_EMAIL column
DESC TABLE TRUCK;
</code></pre>
<p>Note the unique key value for the TRUCK_EMAIL column.</p>
<p>Due to the unique constraint, if we attempt to insert two records with the same email address, the statement will fail. To test it run the following statement:</p>
<pre><code language="language-sql" class="language-sql">-- select one of the existing email addresses
SET TRUCK_EMAIL = (SELECT TRUCK_EMAIL FROM TRUCK LIMIT 1);
-- Since TRUCK_ID is a primary key we need to calculate a new primary key value in order not to fail on the &#34;Primary key already exists&#34; error.
SET MAX_TRUCK_ID = (SELECT MAX(TRUCK_ID) FROM TRUCK);
--Increment max truck_id by one
SET NEW_TRUCK_ID = $MAX_TRUCK_ID+1;
insert into TRUCK values ($NEW_TRUCK_ID,2,&#39;Stockholm&#39;,&#39;Stockholm län&#39;,&#39;Stockholm&#39;,&#39;Sweden&#39;,&#39;SE&#39;,1,2001,&#39;Freightliner&#39;,&#39;MT45 Utilimaster&#39;,0,276,&#39;2020-10-01&#39;,$TRUCK_EMAIL,CURRENT_TIMESTAMP());
</code></pre>
<p>Since we configured the column TRUCK_EMAIL in table TRUCK as UNIQUE the statement failed and we should receive the following error message: &#34;Duplicate key value violates unique constraint &#34;SYS_INDEX_TRUCK_UNIQUE_TRUCK_EMAIL&#34;&#34;</p>
<p>Now we will create new unique email address and insert a new record to table TRUCK:</p>
<pre><code language="language-sql" class="language-sql">-- Create new unique email address
SET NEW_UNIQUE_EMAIL = CONCAT($NEW_TRUCK_ID, &#39;_truck@email.com&#39;);
insert into TRUCK values ($NEW_TRUCK_ID,2,&#39;Stockholm&#39;,&#39;Stockholm län&#39;,&#39;Stockholm&#39;,&#39;Sweden&#39;,&#39;SE&#39;,1,2001,&#39;Freightliner&#39;,&#39;MT45 Utilimaster&#39;,0,276,&#39;2020-10-01&#39;,$NEW_UNIQUE_EMAIL,CURRENT_TIMESTAMP());
</code></pre>
<p>Statement should run successfully.</p>
<h2 is-upgraded>Step 4.2 Insert Foreign Keys Constraints</h2>
<p>In this step we will test foreign key constraint.</p>
<p>First, let&#39;s recall the foreign key constraints we defined in the ORDER_HEADER table by executing the <a href="https://docs.snowflake.com/en/sql-reference/functions/get_ddl" target="_blank">GET_DDL</a>. Note the foreign key constraints related to the TRUCK_ID column in the output.</p>
<pre><code language="language-sql" class="language-sql">-- Return the DDL used to create table named ORDER_HEADER:
select get_ddl(&#39;table&#39;, &#39;ORDER_HEADER&#39;);
</code></pre>
<p>Second, we will try to insert a new record to table ORDER_HEADER with non existing truck id. It is expected that the insert statement would fail since we will violate the TRUCK table foreign key constraint.</p>
<pre><code language="language-sql" class="language-sql">-- Since ORDER_ID is a primary key we need to calculate a new primary key value in order not to fail on the &#34;Primary key already exists&#34; error.
SET MAX_ORDER_ID = (SELECT MAX(ORDER_ID) FROM ORDER_HEADER);
--Increment max ORDER_ID by one
SET NEW_ORDER_ID = ($MAX_ORDER_ID +1);
SET NONE_EXIST_TRUCK_ID = -1;
-- Insert new record to table ORDER_HEADER
insert into ORDER_HEADER values ($NEW_ORDER_ID,$NONE_EXIST_TRUCK_ID,6090,0,0,0,&#39;16:00:00&#39;,&#39;23:00:00&#39;,&#39;&#39;,&#39;2022-02-18 21:38:46.000&#39;,&#39;&#39;,&#39;USD&#39;,17.0000,&#39;&#39;,&#39;&#39;,17.0000,&#39;&#39;);
</code></pre>
<p>The statement should fail and we should receive the following error message:</p>
<p>Foreign key constraint &#34;SYS_INDEX_ORDER_HEADER_FOREIGN_KEY_TRUCK_ID_TRUCK_TRUCK_ID&#34; is violated.</p>
<p>Now we will use the new NEW_TRUCK_ID variable we used in previous step and insert a new record to table ORDER_HEADER:</p>
<pre><code language="language-sql" class="language-sql">-- Insert new record to table ORDER_HEADER
insert into ORDER_HEADER values ($NEW_ORDER_ID,$NEW_TRUCK_ID,6090,0,0,0,&#39;16:00:00&#39;,&#39;23:00:00&#39;,&#39;&#39;,&#39;2022-02-18 21:38:46.000&#39;,&#39;&#39;,&#39;USD&#39;,17.0000,&#39;&#39;,&#39;&#39;,17.0000,&#39;&#39;);
</code></pre>
<p>Statement should run successfully.</p>
<h2 is-upgraded>Step 4.3 Truncated Active Foreign Key Constraint</h2>
<p>In this step, we will test that the table referenced by a foreign key constraint cannot be truncated as long as the foreign key relationship exists. To test it run the following <a href="https://docs.snowflake.com/en/sql-reference/sql/truncate-table" target="_blank">TRUNCATE</a> statement:</p>
<pre><code language="language-sql" class="language-sql">-- truncate the table
TRUNCATE TABLE TRUCK;
</code></pre>
<p>The statement should fail and we should receive the following error message: &#34;391458 (0A000): Hybrid table ‘TRUCK&#39; cannot be truncated as it is involved in active foreign key constraints.&#34;</p>
<h2 is-upgraded>Step 4.4 Delete Foreign Key Constraint</h2>
<p>In this step, we will test that a record referenced by a foreign key constraint cannot be deleted as long as the foreign key reference relationship exists.</p>
<p>To test it run the following <a href="https://docs.snowflake.com/en/sql-reference/sql/delete" target="_blank">DELETE</a> statement:</p>
<pre><code language="language-sql" class="language-sql">DELETE FROM TRUCK WHERE TRUCK_ID = $NEW_TRUCK_ID;
</code></pre>
<p>The statement should fail and we should receive the following error message: &#34;Foreign keys that reference key values still exist.&#34;</p>
<p>To successfully delete a record referenced by a foreign key constraint, you must first delete the corresponding reference record in the ORDER_HEADER table. Only after completing this step you can proceed to delete the referenced record in the TRUCK table. To test this, execute the following DELETE statements:</p>
<pre><code language="language-sql" class="language-sql">DELETE FROM ORDER_HEADER WHERE ORDER_ID = $NEW_ORDER_ID;
DELETE FROM TRUCK WHERE TRUCK_ID = $NEW_TRUCK_ID;
</code></pre>
<p>Both statements should run successfully.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Row Level Locking" duration="5">
        <p>Unlike standard tables, which utilize partition or table-level locking, hybrid tables employ row-level locking for update operations. Row Level locking allows for concurrent updates on independent records. In this step, we will test concurrent updates to different records.</p>
<p>In order to test it we will run concurrent updates on two different records in the hybrid table ORDER_HEADER. We will use the main worksheet &#34;Hybrid Table - QuickStart&#34; we created in step 2.1 and will create a new worksheet &#34;Hybrid Table - QuickStart session 2&#34; to simulate a new session. From the &#34;Hybrid Table - QuickStart&#34; worksheet we will start a new transaction using the <a href="https://docs.snowflake.com/en/sql-reference/sql/begin" target="_blank">BEGIN</a> statement, and run an update DML statement. Before running the <a href="https://docs.snowflake.com/en/sql-reference/sql/commit" target="_blank">COMMIT</a> transaction statement we will open the &#34;Hybrid Table - QuickStart session 2&#34; worksheet and run another update DML statement. finally we will commit the open transaction.</p>
<h2 is-upgraded>Step 5.1 Creating a New Worksheet</h2>
<p>Within Worksheets, click the &#34;+&#34; button in the top-right corner of Snowsight and choose &#34;SQL Worksheet&#34;</p>
<p class="image-container"><img alt="Create New SQL Worksheet" src="img/b82a768bfd09f1bf.png"></p>
<p>Rename the Worksheet by clicking on the auto-generated Timestamp name and inputting &#34;Hybrid Table - QuickStart session 2&#34;. The &#34;Hybrid Table - QuickStart Session 2&#34; worksheet that we have just created will only be used in the current step.</p>
<h2 is-upgraded>Step 5.2 Running concurrent updates</h2>
<p>Open &#34;Hybrid Table - QuickStart&#34; worksheet and then select and set MAX_ORDER_ID variable.</p>
<pre><code language="language-sql" class="language-sql">-- Step 5
-- Set step context
USE ROLE HYBRID_QUICKSTART_ROLE;
USE WAREHOUSE HYBRID_QUICKSTART_WH;
USE DATABASE HYBRID_QUICKSTART_DB;
USE SCHEMA DATA;

SET MAX_ORDER_ID = (SELECT max(order_id) from ORDER_HEADER);
SELECT $MAX_ORDER_ID;
</code></pre>
<p>Note the MAX_ORDER_ID variable value.</p>
<p>Start a new transaction and run the first update DML statement.</p>
<pre><code language="language-sql" class="language-sql">-- Begins a transaction in the current session.
BEGIN;
-- Update record
UPDATE ORDER_HEADER
SET order_status = &#39;COMPLETED&#39;
WHERE order_id = $MAX_ORDER_ID;
</code></pre>
<p>Note that we didn&#39;t commit the transaction so now there is an open lock on the record WHERE order_id = $MAX_ORDER_ID.</p>
<p>Run <a href="https://docs.snowflake.com/en/sql-reference/sql/show-transactions" target="_blank">SHOW TRANSACTIONS</a> statement. It is expected that the SHOW TRANSACTIONS statement would return 1 single open transaction.</p>
<pre><code language="language-sql" class="language-sql">-- List all running transactions
SHOW TRANSACTIONS;
</code></pre>
<p>Now open the &#34;Hybrid Table - QuickStart session 2&#34; worksheet and then select and set MIN_ORDER_ID variable.</p>
<pre><code language="language-sql" class="language-sql">-- Step 5
-- Set step context
USE ROLE HYBRID_QUICKSTART_ROLE;
USE WAREHOUSE HYBRID_QUICKSTART_WH;
USE DATABASE HYBRID_QUICKSTART_DB;
USE SCHEMA DATA;

SET MIN_ORDER_ID = (SELECT min(order_id) from ORDER_HEADER);
SELECT $MIN_ORDER_ID;
</code></pre>
<p>Note that the MIN_ORDER_ID variable value is different from the MAX_ORDER_ID variable value we used in the first update DML statement.</p>
<p>Run second update DML statement.</p>
<pre><code language="language-sql" class="language-sql">-- Update record
UPDATE ORDER_HEADER
SET order_status = &#39;COMPLETED&#39;
WHERE order_id = $MIN_ORDER_ID;
</code></pre>
<p>Since hybrid tables employ row-level locking and the open transaction locks the row WHERE order_id = $MAX_ORDER_ID the update statement should run successfully.</p>
<p>Open &#34;Hybrid Table - QuickStart&#34; worksheet and run a commit statement to commit the open transaction.</p>
<pre><code language="language-sql" class="language-sql">-- Commits an open transaction in the current session.
COMMIT;
</code></pre>
<p>Run the following statement to view the updated records:</p>
<pre><code language="language-sql" class="language-sql">SELECT * from ORDER_HEADER where order_status = &#39;COMPLETED&#39;;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Consistency" duration="5">
        <p>In this step, we will demonstrate a unique hybrid tables feature that shows how we can run multi-statement operations natively, easily and effectively in one consistent atomic transaction across both hybrid and standard table types. We&#39;ll execute a use case where a truck owner acquires a new truck of the same model. Consequently we will have to update the YEAR column for relevant record in the TRUCK hybrid table to reflect the change. As a result of this update, the TRUCK_HISTORY standard table will be promptly updated to track and preserve changes over time.</p>
<h2 is-upgraded>Step 6.1 Run Multi Statement Transaction</h2>
<p>First We&#39;ll initiate a new transaction using the <a href="https://docs.snowflake.com/en/sql-reference/sql/begin" target="_blank">BEGIN</a> to ensure that the series of operations is treated as a single, atomic unit.<br> Second We&#39;ll execute a multi-statement DML that will:</p>
<ul>
<li>Update the relevant truck record in the TRUCK hybrid table.</li>
<li>Update the corresponding record in the TRUCK_HISTORY table by setting the RECORD_END_TIME to mark the end of its validity.</li>
<li>Insert a new record in the TRUCK_HISTORY table, capturing the updated information.</li>
</ul>
<p>Finally, <a href="https://docs.snowflake.com/en/sql-reference/sql/commit" target="_blank">COMMIT</a> the transaction.</p>
<pre><code language="language-sql" class="language-sql">-- Step 6
-- Set step context
USE ROLE HYBRID_QUICKSTART_ROLE;
USE WAREHOUSE HYBRID_QUICKSTART_WH;
USE DATABASE HYBRID_QUICKSTART_DB;
USE SCHEMA DATA;

-- Begins a transaction in the current session.
begin;
-- Set current timestamp. We will use it to set timestamp columns. 
SET CURRENT_TIMESTAMP = CURRENT_TIMESTAMP();
-- Update YEAR and RECORD_START_TIME columns for the relevant truck record in the TRUCK Hybrid table.
update TRUCK set YEAR = &#39;2024&#39;,RECORD_START_TIME=$CURRENT_TIMESTAMP where TRUCK_ID = 1;
-- Update the corresponding record in the TRUCK_HISTORY table by setting the RECORD_END_TIME to mark the end of its validity.
update TRUCK_HISTORY SET RECORD_END_TIME=$CURRENT_TIMESTAMP where TRUCK_ID = 1 and RECORD_END_TIME IS NULL;
-- Insert a new record in the TRUCK_HISTORY table, capturing the updated information.
insert into TRUCK_HISTORY select *,NULL AS RECORD_END_TIME from TRUCK where TRUCK_ID = 1;
-- commit the transaction
commit;
</code></pre>
<h2 is-upgraded>Step 6.3 Explore Data</h2>
<p>Now we can run select queries to review the new inserted records.</p>
<pre><code language="language-sql" class="language-sql">-- Should return two records 
select * from TRUCK_HISTORY where TRUCK_ID = 1;
-- Should return one updated record 
select * from TRUCK where TRUCK_ID = 1;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Hybrid Querying" duration="5">
        <p>In this step, we will test the join between hybrid and standard tables. We will use the TRUCK_HISTORY table and join it with the hybrid table ORDER_HEADER.</p>
<h2 is-upgraded>Step 7.1 Explore Data</h2>
<p>In the Setup step, we already created and loaded data into the ORDER_HEADER tables. Now we can run a few queries and review some information to get familiar with it.</p>
<pre><code language="language-sql" class="language-sql">-- Step 7
-- Set step context
USE ROLE HYBRID_QUICKSTART_ROLE;
USE WAREHOUSE HYBRID_QUICKSTART_WH;
USE DATABASE HYBRID_QUICKSTART_DB;
USE SCHEMA DATA;

-- Lists the tables for which you have access privileges in hybrid_quickstart_db database
show tables in database hybrid_quickstart_db;
-- Select name and is_hybrid columns
select &#34;name&#34;, &#34;is_hybrid&#34; from table(result_scan(last_query_id()));

-- Simple query to look at 10 rows of data from standard table TRUCK_HISTORY
select * from TRUCK_HISTORY limit 10;
-- Simple query to look at 10 rows of data from hybrid table ORDER_HEADER
select * from ORDER_HEADER limit 10;
</code></pre>
<h2 is-upgraded>Step 7.2 Join Hybrid Table and Standard Table</h2>
<p>In order to test the join of the hybrid table ORDER_HEADER with the standard table TRUCK_HISTORY, let&#39;s run the join statement.</p>
<pre><code language="language-sql" class="language-sql">-- Set ORDER_ID variable
set ORDER_ID = (select order_id from ORDER_HEADER limit 1);

-- Join tables ORDER_STATE_HYBRID and TRUCK_HISTORY
select HY.*,ST.* from ORDER_HEADER as HY join TRUCK_HISTORY as ST on HY.truck_id = ST.TRUCK_ID where HY.ORDER_ID = $ORDER_ID and ST.RECORD_END_TIME IS NULL;
</code></pre>
<p>After executing the join statement, examine and analyze the data in the result set.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Security &amp; Governance" duration="5">
        <p>In this step, we will demonstrate that the security and governance functionalities applied to the standard table also extend to the hybrid table, by running two security use cases.</p>
<h2 is-upgraded>Step 8.1 Hybrid Table Access Control and User Management</h2>
<p><a href="https://docs.snowflake.com/en/user-guide/security-access-control-overview" target="_blank">Role-based access control (RBAC)</a> in Snowflake for hybrid tables is the same as standard tables. The purpose of this exercise is to give you a chance to see how you can manage access to hybrid table data in Snowflake by granting privileges to some roles.</p>
<p>First we will create a new HYBRID_QUICKSTART_BI_USER_ROLE role</p>
<pre><code language="language-sql" class="language-sql">-- Step 8
-- Set step context
USE ROLE HYBRID_QUICKSTART_ROLE;
USE WAREHOUSE HYBRID_QUICKSTART_WH;
USE DATABASE HYBRID_QUICKSTART_DB;
USE SCHEMA DATA;

USE ROLE ACCOUNTADMIN;
CREATE ROLE HYBRID_QUICKSTART_BI_USER_ROLE;
SET MY_USER = CURRENT_USER();
GRANT ROLE HYBRID_QUICKSTART_BI_USER_ROLE TO USER IDENTIFIER($MY_USER);
</code></pre>
<p>Then we will grant USAGE privileges to HYBRID_QUICKSTART_WH warehouse, HYBRID_QUICKSTART_DB database, and all its schemas to role HYBRID_QUICKSTART_BI_USER_ROLE</p>
<pre><code language="language-sql" class="language-sql">-- Use HYBRID_QUICKSTART_ROLE role
USE ROLE HYBRID_QUICKSTART_ROLE;
GRANT USAGE ON WAREHOUSE HYBRID_QUICKSTART_WH TO ROLE HYBRID_QUICKSTART_BI_USER_ROLE;
GRANT USAGE ON DATABASE HYBRID_QUICKSTART_DB TO ROLE HYBRID_QUICKSTART_BI_USER_ROLE;
GRANT USAGE ON ALL SCHEMAS IN DATABASE HYBRID_QUICKSTART_DB TO HYBRID_QUICKSTART_BI_USER_ROLE;
</code></pre>
<p>Use the newly created role and try to select some data from ORDER_STATE_HYBRID hybrid table</p>
<pre><code language="language-sql" class="language-sql">-- Use HYBRID_QUICKSTART_BI_USER_ROLE role
USE ROLE HYBRID_QUICKSTART_BI_USER_ROLE;
-- Use HYBRID_QUICKSTART_BI_USER_ROLE database
USE DATABASE HYBRID_QUICKSTART_DB;
USE SCHEMA DATA;

select * from ORDER_HEADER limit 10;
</code></pre>
<p>We&#39;re not able to select any data. That&#39;s because the role HYBRID_QUICKSTART_BI_USER_ROLE has not been granted the necessary privileges.</p>
<p>Use role HYBRID_QUICKSTART_ROLE and grant role HYBRID_QUICKSTART_BI_USER_ROLE select privileges on all tables in schema DATA.</p>
<pre><code language="language-sql" class="language-sql">-- Use HYBRID_QUICKSTART_ROLE role
USE ROLE HYBRID_QUICKSTART_ROLE;
GRANT SELECT ON ALL TABLES IN SCHEMA DATA TO ROLE HYBRID_QUICKSTART_BI_USER_ROLE;
</code></pre>
<p>Try again to select some data from ORDER_STATE_HYBRID hybrid table</p>
<pre><code language="language-sql" class="language-sql">-- Use HYBRID_QUICKSTART_BI_USER_ROLE role
USE ROLE HYBRID_QUICKSTART_BI_USER_ROLE;
select * from ORDER_HEADER limit 10;
</code></pre>
<p>This time it worked! This is because the HYBRID_QUICKSTART_BI_USER_ROLE role has the appropriate privileges at all levels of the hierarchy.</p>
<h2 is-upgraded>Step 8.2 Hybrid Table Masking Policy</h2>
<p>In this step, we will create a new masking policy object and apply it to the TRUCK_EMAIL column in the TRUCK hybrid table using an ALTER TABLE... ALTER COLUMN statement.</p>
<p>First, we will create a new masking policy.</p>
<pre><code language="language-sql" class="language-sql">-- Step 8
-- Set step context
USE ROLE HYBRID_QUICKSTART_ROLE;
USE WAREHOUSE HYBRID_QUICKSTART_WH;
USE DATABASE HYBRID_QUICKSTART_DB;
USE SCHEMA DATA;

--full column masking version, always masks
create masking policy hide_column_values as
(col_value varchar) returns varchar -&gt;
  case
     WHEN current_role() IN (&#39;HYBRID_QUICKSTART_ROLE&#39;) THEN col_value
    else &#39;***MASKED***&#39;
  end;
</code></pre>
<p>Apply the policy to the hybrid table.</p>
<pre><code language="language-sql" class="language-sql">-- set masking policy
alter table TRUCK modify column TRUCK_EMAIL
set masking policy hide_column_values using (TRUCK_EMAIL);
</code></pre>
<p>Since we are using the HYBRID_QUICKSTART_ROLE role column TRUCK_EMAIL should not be masked. Run the statement to see if it has the desired effect</p>
<pre><code language="language-sql" class="language-sql">select * from TRUCK limit 10;
</code></pre>
<p>Since we are using HYBRID_QUICKSTART_BI_USER_ROLE role column TRUCK_EMAIL should be masked. Run the statement to see if it has the desired effect</p>
<pre><code language="language-sql" class="language-sql">-- Use HYBRID_QUICKSTART_BI_USER_ROLE role
USE ROLE HYBRID_QUICKSTART_BI_USER_ROLE;
select * from TRUCK limit 10;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Cleanup" duration="0">
        <p>To clean up your Snowflake environment you can run the following SQL Statements:</p>
<pre><code language="language-sql" class="language-sql">-- Step 9
-- Set step context
USE ROLE HYBRID_QUICKSTART_ROLE;
USE WAREHOUSE HYBRID_QUICKSTART_WH;
USE DATABASE HYBRID_QUICKSTART_DB;
USE SCHEMA DATA;

DROP DATABASE HYBRID_QUICKSTART_DB;
DROP WAREHOUSE HYBRID_QUICKSTART_WH;
USE ROLE ACCOUNTADMIN;
DROP ROLE HYBRID_QUICKSTART_ROLE;
DROP ROLE HYBRID_QUICKSTART_BI_USER_ROLE;
</code></pre>
<p>The last step is to manually delete &#34;Hybrid Table - QuickStart&#34; and &#34;Hybrid Table - QuickStart session 2&#34; worksheets.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Conclusion and Resources" duration="0">
        <h2 is-upgraded>What You Learned</h2>
<p>Having completed this quickstart you have successfully</p>
<ul>
<li>Created Hybrid Table and Bulk Load Data</li>
<li>Explore the Data</li>
<li>Learned about Unique and Foreign Keys Constraints</li>
<li>Learned about hybrid table unique row level locking</li>
<li>Learned about consistency and how you can run multi-statement operation in one consistent atomic transaction across both hybrid and standard table types</li>
<li>Learned about hybrid querying and how to join standard table and hybrid table</li>
<li>Learned that security and governance principles apply similarly to both hybrid and standard tables</li>
</ul>
<h2 is-upgraded>Related Resources:</h2>
<ul>
<li><a href="https://www.snowflake.com/en/data-cloud/workloads/unistore/" target="_blank">Snowflake Unistore Landing Page</a></li>
<li><a href="https://docs.snowflake.com/en/user-guide/tables-hybrid" target="_blank">Snowflake Documentation for Hybrid Tables</a></li>
<li><a href="https://www.snowflake.com/blog/simplify-application-development-hybrid-tables" target="_blank">Simplify Application Development Hybrid Tables Blog</a></li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/native-shim.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/custom-elements.min.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/prettify.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>
  <script type="text/javascript">
    window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var r=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(r?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["addEventProperties","addUserProperties","clearEventProperties","identify","removeEventProperty","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
    heap.load("2025084205");
  </script>
</body>
</html>
