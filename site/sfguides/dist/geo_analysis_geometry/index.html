
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Geospatial Analysis using Geometry and Geography Data Type</title>

  
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5Q8R2G');</script>
  

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-08H27EW14N"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-08H27EW14N');
</script>

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q8R2G"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  
  <google-codelab-analytics gaid="UA-41491190-9"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="geo_analysis_geometry"
                  title="Geospatial Analysis using Geometry and Geography Data Type"
                  environment="web"
                  feedback-link="https://github.com/Snowflake-Labs/sfguides/issues">
    
      <google-codelab-step label="Overview" duration="10">
        <p>Geospatial query capabilities in Snowflake are built upon a combination of data types and specialized query functions that can be used to parse, construct, and run calculations over geospatial objects. This guide will introduce you to the <code>GEOMETRY</code> data type, help you understand geospatial formats supported by Snowflake and walk you through the use of a variety of functions on sample geospatial data sets.</p>
<h2 is-upgraded>Prerequisites</h2>
<ul>
<li>Quick Video <a href="https://www.youtube.com/watch?v=fEtoYweBNQ4&ab_channel=SnowflakeInc." target="_blank">Introduction to Snowflake</a></li>
<li>Snowflake <a href="https://www.youtube.com/watch?v=us6MChC8T9Y&ab_channel=SnowflakeInc." target="_blank">Data Loading Basics</a> Video</li>
<li><a href="https://docs.carto.com/getting-started/carto-in-a-nutshell" target="_blank">CARTO in a nutshell </a>web guide</li>
<li><a href="https://www.youtube.com/watch?v=9W_Attbs-fY" target="_blank">CARTO Spatial Extension for Snowflake</a> video</li>
</ul>
<h2 class="checklist" is-upgraded>What You&#39;ll Learn</h2>
<ul class="checklist">
<li>How to acquire geospatial data from the Snowflake Marketplace</li>
<li>How to load geospatial data from a Stage</li>
<li>How to interpret the <code>GEOMETRY</code> data type and how it differs from the <code>GEOGRAPHY</code></li>
<li>How to understand the different formats that <code>GEOMETRY</code> can be expressed in</li>
<li>How to do spatial analysis using the <code>GEOMETRY</code> and <code>GEOGRAPHY</code> data types</li>
<li>How to use Python UDFs for reading Shapefiles and creating custom functions</li>
<li>How to use Global Discrete Grid and H3 functions</li>
<li>How to use Search Optimization to speed up geospatial queries</li>
</ul>
<h2 is-upgraded>What You&#39;ll Need</h2>
<ul>
<li>A supported Snowflake <a href="https://docs.snowflake.com/en/user-guide/setup.html" target="_blank">Browser</a></li>
<li>Sign-up for a <a href="https://signup.snowflake.com/?utm_cta=quickstarts_" target="_blank">Snowflake Trial</a>  OR have access to an existing Snowflake account with the <code>ACCOUNTADMIN</code> role or the <code>IMPORT SHARE</code> privilege. Select the Enterprise edition, AWS as a cloud provider and US East (Northern Virginia) or EU (Frankfurt) as a region.</li>
<li>Sign-up for a  <a href="http://app.carto.com/signup" target="_blank">CARTO Trial</a> (OR  have access to an existing CARTO account). Select the same region (continent) as for the Snowflake account.</li>
</ul>
<h2 is-upgraded>What You&#39;ll Build</h2>
<p>A sample use case that involves energy grids and LTE cell towers in the Netherlands You will answer the following questions:</p>
<ul>
<li>What is the length of all energy grids in each municipality in the Netherlands?</li>
<li>What cell towers lack electricity cables nearby?</li>
<li>What municipalities in the Netherlands have good/poor LTE coverage?</li>
<li>What percent of the Dutch highways have LTE coverage?</li>
<li>What is the estimated quality of LTE signal on Dutch highways?</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Setup your Account" duration="5">
        <p>If this is the first time you are logging into the Snowflake UI, you will be prompted to enter your account name or account URL that you were given when you acquired a trial. The account URL contains your <a href="https://docs.snowflake.com/en/user-guide/connecting.html#your-snowflake-account-name" target="_blank">account name</a> and potentially the region. You can find your account URL in the email that was sent to you after you signed up for the trial.</p>
<p>Click <code>Sign-in</code> and you will be prompted for your username and password.</p>
<aside class="special"><p> If this is not the first time you are logging into the Snowflake UI, you should see a &#34;Select an account to sign into&#34; prompt and a button for your account name listed below it. Click the account you wish to access and you will be prompted for your username and password (or another authentication mechanism).</p>
</aside>
<h2 is-upgraded>Increase Your Account Permission</h2>
<p>The Snowflake web interface has a lot to offer, but for now, switch your current role from the default <code>SYSADMIN</code> to <code>ACCOUNTADMIN</code>. This increase in permissions will allow you to create shared databases from Snowflake Marketplace listings.</p>
<aside class="special"><p> If you don&#39;t have the <code>ACCOUNTADMIN</code> role, switch to a role with <code>IMPORT SHARE</code> privileges instead.</p>
</aside>
<p class="image-container"><img style="width: 500.00px" src="img/b9575209bfee61ca.png"></p>
<h2 is-upgraded>Create a Virtual Warehouse</h2>
<p>You will need to create a Virtual Warehouse to run queries.</p>
<ul>
<li>Navigate to the <code>Admin > Warehouses</code> screen using the menu on the left side of the window</li>
<li>Click the big blue <code>+ Warehouse</code> button in the upper right of the window</li>
<li>Create a Large Warehouse as shown in the screen below</li>
</ul>
<p class="image-container"><img style="width: 500.00px" src="img/1e9fb04bc904a0d2.png"></p>
<p>Be sure to change the <code>Suspend After (min)</code> field to 5 min to avoid wasting compute credits.</p>
<h2 is-upgraded>Acknowledge the Snowflake Third Party Terms</h2>
<p>To use the packages provided by Anaconda inside Snowflake, you must acknowledge the Snowflake Third Party Terms.</p>
<ul>
<li>Select Admin » Billing &amp; Terms.</li>
<li>In the Anaconda section, select Enable.</li>
<li>In the Anaconda Packages dialog, click the link to review the Snowflake Third Party Terms page.</li>
<li>If you agree to the terms, select <code>Acknowledge & Continue</code>.</li>
</ul>
<h2 is-upgraded>Create a Database and Schema</h2>
<p>Navigate to the query editor by clicking on  <code>Worksheets</code>  on the top left navigation bar and choose your warehouse.</p>
<ul>
<li>Click the + Worksheet button in the upper right of your browser window. This will open a new window.</li>
<li>In the new Window, make sure <code>ACCOUNTADMIN</code> and <code>MY_WH</code> (or whatever your warehouse is named) are selected in the upper right of your browser window.</li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/2ab2115d49c67d4b.png"></p>
<p>Create a new database and schema where you will store datasets in the <code>GEOMETRY</code> data type. Copy &amp; paste the SQL below into your worksheet editor, put your cursor somewhere in the text of the query you want to run (usually the beginning or end), and either click the blue &#34;Play&#34; button in the upper right of your browser window, or press <code>CTRL+Enter</code> or <code>CMD+Enter</code> (Windows or Mac) to run the query.</p>
<pre><code>CREATE OR REPLACE DATABASE GEOLAB;
CREATE OR REPLACE schema GEOLAB.GEOMETRY;
// Set the working database schema
USE SCHEMA GEOLAB.GEOMETRY;
</code></pre>
<h2 is-upgraded>Connect Snowflake and Carto</h2>
<p>Let&#39;s connect your Snowflake to CARTO so you can run and visualize the queries in the following exercises of this workshop.</p>
<p>Access the CARTO Workspace: <a href="http://app.carto.com/" target="_blank">app.carto.com</a></p>
<p>Go to the Connections section in the Workspace, where you can find the list of all your current connections.</p>
<p class="image-container"><img style="width: 700.00px" src="img/db82211120d23db7.png"></p>
<p>To add a new connection, click on <code>New connection</code> and follow these steps:</p>
<ol type="1">
<li>Select Snowflake.</li>
<li>Click the <code>Setup connection</code> button.</li>
<li>Enter the connection parameters and credentials.</li>
</ol>
<p>These are the parameters you need to provide:</p>
<ul>
<li><strong>Name</strong> for your connection: You can register different connections with the Snowflake connector. You can use the name to identify the connections.</li>
<li><strong>Username</strong>: Name of the user account.</li>
<li><strong>Password</strong>: Password for the user account.</li>
<li><strong>Account</strong>: Hostname for your account. One way to get it is to check the Snowflake activation email, which contains the account_name within the URL ( &lt;account_name&gt;.snowflakecomputing.com ). Just enter what&#39;s on the account_name, i.e ok36557.us-east-2.aws</li>
<li><strong>Warehouse (optional)</strong>: Default warehouse that will run your queries. Use MY_WH.</li>
</ul>
<aside class="warning"><p> Use MY_WH or the name of the data warehouse you created in the previous step otherwise some queries will fail because CARTO won&#39;t know which warehouse to run them against.</p>
</aside>
<ul>
<li><strong>Database (optional)</strong>. Default database to run your queries. Use GEOLAB.</li>
<li><strong>Role (optional)</strong>. Default Role to run your queries. Use ACCOUNTADMIN.</li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/dabb63ec691a4abc.png"></p>
<p>Once you have entered the parameters, you can click the Connect button. CARTO will try to connect to your Snowflake account. If everything is OK, your new connection will be registered.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Acquire Marketplace Data and Analytics Toolbox" duration="5">
        <p>The first step in the guide is to acquire geospatial data sets that you can freely use to explore the basics of Snowflake&#39;s geospatial functionality.  The best place to acquire this data is the Snowflake Marketplace!</p>
<ul>
<li>Navigate to the <code>Marketplace</code> screen using the menu on the left side of the window</li>
<li>Search for <code>OpenCelliD</code> in the search bar</li>
<li>Find and click the <code>OpenCelliD - Open Database of Cell Towers</code> tile</li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/733037ef599ccab.png"></p>
<ul>
<li>Once in the listing, click the big blue <code>Get</code> button</li>
</ul>
<aside class="warning"><p> On the <code>Get</code> screen, you may be prompted to complete your <code>user profile</code> if you have not done so before. Click the link as shown in the screenshot below. Enter your name and email address into the profile screen and click the blue <code>Save</code> button. You will be returned to the <code>Get</code> screen.</p>
</aside>
<p class="image-container"><img style="width: 500.00px" src="img/266bfe4f1f5ba1a3.png"></p>
<ul>
<li>On the <code>Get Data</code> screen, change the name of the database from the default to <code>OPENCELLID</code>, as this name is shorter, and all future instructions will assume this name for the database.</li>
</ul>
<p class="image-container"><img style="width: 500.00px" src="img/86244de138cc244e.png"></p>
<p>Congratulations! You have just created a shared database from a listing on the Snowflake Marketplace.</p>
<p>Similarly to the above dataset, search and get the <code>Netherlands Open Map Data - Sonra</code> dataset from the Marketplace and rename it to <code>osm_nl</code>.</p>
<p class="image-container"><img style="width: 500.00px" src="img/f46c61d31c1209e2.png"></p>
<aside class="warning"><p> After clicking &#34;Get&#34; you may see a message saying &#34;Getting Data Ready. This will take at least 10 minutes.&#34;. In this case simply continue this quickstart and come back to this step when you start using this dataset.</p>
</aside>
<h2 is-upgraded>Install CARTO Analytics Toolbox from the Snowflake Marketplace</h2>
<p>Now you can acquire CARTO&#39;s Analytics Toolbox from the Snowflake Marketplace. This will share UDFs (User defined functions) to your account which will allow you to perform even more geospatial analytics.</p>
<ul>
<li>Similar to how you did with the data in the previous steps, navigate to the <code>Marketplace</code> screen using the menu on the left side of the window</li>
<li>Search for <code>CARTO</code> in the search bar</li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/1ea45be8fefae346.png"></p>
<ul>
<li>Find and click the <code>Analytics Toolbox</code>  tile</li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/8989fbb85e5b9106.png"></p>
<ul>
<li>Click on big blue <code>Get</code>  button</li>
<li>In the options, name the database <code>CARTO</code> and optionally add more roles that can access the database</li>
</ul>
<p class="image-container"><img style="width: 500.00px" src="img/fb30ccaee6fed7f6.png"></p>
<ul>
<li>Click on <code>Get</code> and then <code>Done</code>.</li>
</ul>
<p>Congratulations! Now you have data and the analytics toolbox!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Load Data from External Storage" duration="5">
        <p>Now that you understand how to get data from Marketplace, let&#39;s try another way of getting data, namely, getting it from the external S3 storage. While you loading data you will learn formats supported by geospatial data types.</p>
<p>For this quickstart we have prepared a dataset with energy grid infrastructure (cable lines) in the Netherlands. It is stored in the CSV format in the public S3 bucket. To import this data, create an external stage using the following SQL command:</p>
<pre><code>CREATE OR REPLACE STAGE geolab.geometry.geostage
  URL = &#39;s3://sfquickstarts/vhol_spatial_analysis_geometry_geography/&#39;;
</code></pre>
<p>Now you will create a new table using the file from that stage. Run the following queries to create a new file format and a new table using the dataset stored in the Stage:</p>
<pre><code>// Create file format
CREATE OR REPLACE FILE FORMAT geocsv TYPE = CSV SKIP_HEADER = 1 FIELD_OPTIONALLY_ENCLOSED_BY = &#39;&#34;&#39;;

CREATE OR REPLACE TABLE geolab.geometry.nl_cables_stations AS 
SELECT to_geometry($1) AS geometry, 
       $2 AS id, 
       $3 AS type 
FROM @geostage/nl_stations_cables.csv (file_format =&gt; &#39;geocsv&#39;);
</code></pre>
<p>Look at the description of the table you just created by running the following queries:</p>
<pre><code>DESC TABLE geolab.geometry.nl_cables_stations;
</code></pre>
<p>The <a href="https://docs.snowflake.com/en/sql-reference/sql/desc.html" target="_blank">desc or describe</a> command shows you the definition of the view, including the columns, their data type, and other relevant details. Notice the <code>geometry</code> column is defined as <code>GEOMETRY</code> type.</p>
<p>Snowflake supports 3 primary geospatial formats and 2 additional variations on those formats. They are:</p>
<ul>
<li><strong>GeoJSON</strong>: a JSON-based standard for representing geospatial data</li>
<li><strong>WKT &amp; EWKT</strong>: a &#34;Well Known Text&#34; string format for representing geospatial data and the &#34;Extended&#34; variation of that format</li>
<li><strong>WKB &amp; EWKB:</strong> a &#34;Well Known Binary&#34; format for representing geospatial data in binary and the &#34;Extended&#34; variation of that format</li>
</ul>
<p>These formats are supported for ingestion (files containing those formats can be loaded into a <code>GEOMETRY</code> typed column), query result display, and data unloading to new files. You don&#39;t need to worry about how Snowflake stores the data under the covers but rather how the data is displayed to you or unloaded to files through the value of session variables called <code>GEOMETRY_OUTPUT_FORMAT</code>.</p>
<p>Run the queries below to make sure the current format is GeoJSON.</p>
<pre><code>// Set the output format to GeoJSON
ALTER SESSION SET geometry_output_format = &#39;GEOJSON&#39;;
</code></pre>
<p>The <a href="https://docs.snowflake.com/en/sql-reference/sql/alter-session.html" target="_blank">alter session</a> command lets you set a parameter for your current user session, which in this case is  <code>GEOMETRY_OUTPUT_FORMAT</code>. The default value for those parameters is <code>'GEOJSON'</code>, so normally you wouldn&#39;t have to run this command if you want that format, but this guide wants to be certain the next queries are run with the <code>'GEOJSON'</code> output.</p>
<p>Now run the following query against the <code>nl_cables_stations</code> table to see energy grids in the Netherlands.</p>
<pre><code>SELECT geometry
FROM nl_cables_stations
LIMIT 10;
</code></pre>
<p>In the result set, notice the <code>geometry</code> column and how it displays a JSON representation of spatial objects. It should look similar to this:</p>
<pre><code>{&#34;coordinates&#34;: [[[1.852040750000000e+05, 3.410349640000000e+05], [1.852044840000000e+05,3.410359860000000e+05]], [[1.852390240000000e+05,3.411219340000000e+05], ... ,[1.852800600000000e+05,3.412219960000000e+05]]   ], &#34;type&#34;: &#34;MultiLineString&#34; }
</code></pre>
<p>Unlike <code>GEOGRAPHY</code>, which treats all points as longitude and latitude on a spherical earth, <code>GEOMETRY</code> considers the Earth as a flat surface. More information about Snowflake&#39;s specification can be found <a href="https://docs.snowflake.com/en/sql-reference/data-types-geospatial.html" target="_blank">here</a>. In this example it uses scientific notation and the numbers are much larger than latitude and longitude boundaries [-180; 180].</p>
<p class="image-container"><img style="width: 700.00px" src="img/d269aa575b1cbcab.png"></p>
<p>Now look at the same query but in a different format. Run the following query:</p>
<pre><code>// Set the output format to EWKT
ALTER SESSION SET geometry_output_format = &#39;EWKT&#39;;
</code></pre>
<p>Run the previous <code>SELECT</code> query again and when done, examine the output in the <code>geometry</code> column.</p>
<pre><code>SELECT geometry
FROM nl_cables_stations
LIMIT 10;
</code></pre>
<p>EWKT looks different from GeoJSON, and is arguably more readable. Here you can more clearly see the <a href="https://docs.snowflake.com/en/sql-reference/data-types-geospatial.html#geospatial-object-types" target="_blank">geospatial object types</a>, which are represented below in the example output:</p>
<pre><code>SRID=28992;MULTILINESTRING((185204.075 341034.964,185204.484 341035.986), ... ,(185276.402 341212.688,185279.319 341220.196,185280.06 341221.996))
</code></pre>
<p>EWKT also shows the spatial reference identifier and in our example, you have a dataset in <a href="https://epsg.io/28992" target="_blank">Amersfoort / RD New</a> spatial reference system, that is why the displayed SRID is 28992.</p>
<p>Lastly, look at the WKB output. Run the following query:</p>
<pre><code>// Set the output format to WKB
ALTER SESSION SET geometry_output_format = &#39;WKB&#39;;
</code></pre>
<p>Run the query again, and click on a cell in the <code>geometry</code> column.</p>
<pre><code>SELECT geometry 
FROM nl_cables_stations 
LIMIT 10;
</code></pre>
<p>Notice how WKB is incomprehensible to a human reader. However, this format is handy in data loading/unloading, as it can be more compact than WKT or GeoJSON.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Load Data from Internal Storage" duration="10">
        <p>Now that you have a basic understanding of how the <code>GEOMETRY</code> data type works and what a geospatial representation of data looks like in various output formats, it&#39;s time to walk through a scenario that requires you to use constructors to load data.  You will do it while trying one more way of getting data, namely, from the Shapefile file stored in the internal stage.</p>
<p>First download <a href="https://sfquickstarts.s3.us-west-1.amazonaws.com/vhol_spatial_analysis_geometry_geography/nl_areas.zip" target="_blank">this</a> Shapefile which contains the boundaries of administrative areas in the Netherlands. Then in the navigation menu, select Data &gt; Databases, choose <code>GEOLAB.GEOMETRY</code>, and click Create &gt; Stage &gt; Snowflake Managed.</p>
<p class="image-container"><img src="img/add7662d1564c87d.png"></p>
<p>In the new Window, use the name stageshp and click <code>Create</code>.</p>
<p class="image-container"><img style="width: 500.00px" src="img/2bda279fad7bd118.png"></p>
<p>Then select the newly created Stage and click <code>+ Files</code> to upload a new file.</p>
<p class="image-container"><img src="img/9a54d73eebd0a218.png"></p>
<p>Browse the file you just downloaded and click  <code>Upload</code>.</p>
<p>The file you just uploaded contains the polygons of administrative boundaries in the Netherlands. The data is stored in <a href="https://en.wikipedia.org/wiki/Shapefile" target="_blank">Shapefile format</a> which is not yet supported by Snowflake. But you can load this file using Python UDF and <a href="https://docs.snowflake.com/developer-guide/udf/python/udf-python-examples#label-udf-python-read-files" target="_blank">Dynamic File Access feature</a>. You will also use some packages available in the Snowflake Anaconda channel.</p>
<p>Run the following query that creates a UDF:</p>
<pre><code>CREATE OR REPLACE FUNCTION py_load_geodata(PATH_TO_FILE string, filename string)
RETURNS TABLE (wkt varchar, properties object)
LANGUAGE PYTHON
RUNTIME_VERSION = 3.8
PACKAGES = (&#39;fiona&#39;, &#39;shapely&#39;, &#39;snowflake-snowpark-python&#39;)
HANDLER = &#39;GeoFileReader&#39;
AS $$
from shapely.geometry import shape
from snowflake.snowpark.files import SnowflakeFile
from fiona.io import ZipMemoryFile
class GeoFileReader:        
    def process(self, PATH_TO_FILE: str, filename: str):
    	with SnowflakeFile.open(PATH_TO_FILE, &#39;rb&#39;) as f:
    		with ZipMemoryFile(f) as zip:
    			with zip.open(filename) as collection:
    				for record in collection:
    					yield (shape(record[&#39;geometry&#39;]).wkt, dict(record[&#39;properties&#39;]))
$$;
</code></pre>
<p>This UDF reads a Shapefile and returns its content as a table. Under the hood it uses geospatial libraries <code>fiona</code> and <code>shapely</code>. Run the following query to see the content of the uploaded shapefile.</p>
<pre><code>// Setting EWKT as an output format
ALTER SESSION SET geometry_output_format = &#39;EWKT&#39;;

SELECT to_geometry(wkt) AS geometry,
       properties:NAME_1::string AS province_name,
       properties:NAME_2::string AS municipality_name
FROM table(py_load_geodata(build_scoped_file_url(@stageshp, &#39;nl_areas.zip&#39;), &#39;nl_areas.shp&#39;));
</code></pre>
<p>This query fails with the error: <em>Geometry validation failed: Geometry has invalid self-intersections. A self-intersection point was found at (559963, 5.71069e+06)</em>.</p>
<aside class="warning"><p> The constructor function determines if the shape is valid according to the <a href="https://www.ogc.org/standards/sfa" target="_blank">Open Geospatial Consortium&#39;s Simple Feature Access / Common Architecture</a> standard. If the shape is invalid, the function reports an error and does not create the GEOMETRY object. That is what happened in our example.</p>
</aside>
<p>To fix this you can allow the ingestion of invalid shapes by setting the corresponding parameter to True. Let&#39;s run the SELECT statement again, but update the query to see how many shapes are invalid. Run the following query:</p>
<pre><code>SELECT to_geometry(s =&gt; wkt, allowInvalid =&gt; True) AS geometry,
       st_isvalid(geometry) AS is_valid,
       properties:NAME_1::string AS province_name,
       properties:NAME_2::string AS municipality_name
FROM table(py_load_geodata(build_scoped_file_url(@stageshp, &#39;nl_areas.zip&#39;), &#39;nl_areas.shp&#39;))
ORDER BY is_valid ASC;
</code></pre>
<p class="image-container"><img src="img/c4163b7772109e66.png"></p>
<p>This query completed without error and now you see that the shape of the province Zeeland is invalid. Let&#39;s try to repair it by applying the <a href="https://docs.snowflake.com/en/sql-reference/functions/st_buffer" target="_blank">ST_BUFFER</a> function with a small value for the buffer distance.</p>
<pre><code>SELECT st_buffer(to_geometry(s =&gt; wkt, allowInvalid =&gt; True), -1) AS geometry,
       st_isvalid(geometry) AS is_valid,
       properties:NAME_1::string AS province_name,
       properties:NAME_2::string AS municipality_name
FROM table(py_load_geodata(build_scoped_file_url(@stageshp, &#39;nl_areas.zip&#39;), &#39;nl_areas.shp&#39;))
ORDER BY is_valid ASC;
</code></pre>
<p class="image-container"><img src="img/52ee359ebe451079.png"></p>
<aside class="warning"><p> Using ST_BUFFER with some small positive or negative value for the distance <em>sometimes</em> can help to fix invalid shapes. However, you should remember that the unit of measurement for the distance parameter in the ST_BUFFER will be the same as your data. Therefore, if your data utilizes lon/lat values, the distance&#39;s units will also be degrees.</p>
</aside>
<p>Now all shapes are valid and the data is ready to be ingested. One additional thing you should do is to set SRID, since otherwise it will be set to 0. This dataset is in the reference system <a href="https://epsg.io/32231" target="_blank">WGS 72 / UTM zone 31N</a>, so it makes sense to add the SRID=32231 to the constructor function.</p>
<p>Run the following query:</p>
<pre><code>CREATE OR REPLACE TABLE geolab.geometry.nl_administrative_areas AS
SELECT st_buffer(to_geometry(s =&gt; wkt, srid =&gt; 32231, allowinvalid =&gt; true), -1) AS geometry,
       (CASE WHEN properties:TYPE_1::string IS NULL THEN &#39;Municipality&#39; ELSE &#39;Province&#39; END) AS type,
       properties:NAME_1::string AS province_name,
       properties:NAME_2::string AS municipality_name
FROM TABLE(py_load_geodata(build_scoped_file_url(@stageshp, &#39;nl_areas.zip&#39;), &#39;nl_areas.shp&#39;));
</code></pre>
<p>Excellent! Now that all the datasets are successfully loaded, let&#39;s proceed to the next exciting step: the analysis.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Spatial analysis" duration="25">
        <p>To showcase the capabilities of the GEOMETRY data type, you will explore several use cases. In these scenarios, you&#39;ll assume you are an analyst working for an energy utilities company responsible for maintaining electrical grids.</p>
<h2 is-upgraded>What is the length of the electricity cables?</h2>
<p>In the first use case you will calculate the length of electrical cables your organization is responsible for in each administrative area within the Netherlands. You&#39;ll be utilizing two datasets: with power infrastructure of the Netherlands and the borders of Dutch administrative areas. First, let&#39;s check the sample of each dataset.</p>
<p>Run the following query to see the content of <code>nl_cables_stations</code> table:</p>
<pre><code>SELECT geometry, type
FROM geolab.geometry.nl_cables_stations
LIMIT 5;
</code></pre>
<p>The results look similar to this:</p>
<p class="image-container"><img src="img/9e56eacc51a5f1c5.png"></p>
<p>The spatial data is stored using the <code>GEOMETRY</code> data type and employs the Dutch mapping system, <code>Amersfoort / RD New</code> (SRID = 28992). To view the contents of the table containing the boundaries of the administrative areas in the Netherlands, execute the following query:</p>
<pre><code>SELECT *
FROM geolab.geometry.nl_administrative_areas
LIMIT 5;
</code></pre>
<p class="image-container"><img src="img/786862e2fa0f393.png"></p>
<p>In order to compute the length of all cables per administrative area, it&#39;s essential that both datasets adhere to the same mapping system. You have two options: either project <code>nl_administrative_areas</code> to SRID 28992, or project <code>nl_cables_stations</code> to SRID 32231. For this exercise, let&#39;s choose the first option.</p>
<p>Run the following query:</p>
<pre><code>SELECT t1.province_name,
       sum(st_length(t2.geometry)) AS cables_length
FROM geolab.geometry.nl_administrative_areas AS t1,
     geolab.geometry.nl_cables_stations AS t2
WHERE st_intersects(st_transform(t1.geometry, 28992), t2.geometry)
  AND t1.type = &#39;Province&#39;
GROUP BY 1
ORDER BY 2 DESC;
</code></pre>
<p class="image-container"><img src="img/c90a97a11144a45b.png"></p>
<p>You have five areas densely covered by electricity cables, those are the ones that your company is responsible for. For your first analysis, you will focus on these areas.</p>
<h2 is-upgraded>What cell towers lack electricity cables nearby</h2>
<p>In many areas, especially rural or remote ones, cell towers might be located far from electricity grids. This can pose a challenge in providing a reliable power supply to these towers. They often rely on diesel generators, which can be expensive to operate and maintain and have environmental implications. Furthermore, power outages can lead to disruptions in mobile connectivity, impacting individuals, businesses, and emergency services.</p>
<p>Our analysis aims to identify mobile cell towers that are not near an existing electricity grid. This information could be used to prioritize areas for grid expansion, to improve the efficiency of renewable energy source installations (like solar panels or wind turbines), or to consider alternative energy solutions.</p>
<p>For this and the next examples let&#39;s use <code>GEOGRAPHY</code> data type as it can be easily visualized using CARTO. As a first step, let&#39;s create <code>GEOGRAPHY</code> equivalents for the energy grids and boundaries tables. For that you need to project the <code>geometry</code> column in each of the tables into the mapping system WGS 84 (SRID=4326) and then convert to <code>GEOGRAPHY</code> data type. Run the following queries that create new tables and enable search optimization for each of them in order to increase the performance of spatial operations.</p>
<pre><code>// Creating a table with GEOGRAPHY for nl_administrative_areas
CREATE OR REPLACE SCHEMA GEOLAB.GEOGRAPHY;

CREATE OR REPLACE TABLE geolab.geography.nl_administrative_areas AS
SELECT to_geography(st_asgeojson(st_transform(geometry, 4326))) AS geom,
       type,
       province_name,
       municipality_name
FROM geolab.geometry.nl_administrative_areas
ORDER BY st_geohash(geom);

ALTER TABLE geolab.geography.nl_administrative_areas ADD SEARCH OPTIMIZATION ON GEO(geom);

// Creating a table with GEOGRAPHY for nl_cables_stations
CREATE OR REPLACE TABLE geolab.geography.nl_cables_stations AS
SELECT to_geography(st_asgeojson(st_transform(geometry, 4326))) AS geom,
       id,
       type
FROM geolab.geometry.nl_cables_stations
ORDER BY st_geohash(geom);

ALTER TABLE geolab.geography.nl_cables_stations ADD SEARCH OPTIMIZATION ON GEO(geom);
</code></pre>
<p>You can now go to the CARTO account and visualize administrative areas and cable information in CARTO Builder.</p>
<ul>
<li>Create a new map. Use the navigation menu on the left to get to Maps and then click on (+) New Map.</li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/e28b8c7ec75b2f9b.png"></p>
<ul>
<li>Click on the <code>Add Source From</code> → <code>Data Explorer</code></li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/bfb7d2211a563fa0.png"></p>
<ul>
<li>In the pop-up select your connection and the <code>GEOLAB.GEOGRAPHY.NL_ADMINISTRATIVE_AREAS</code> table.</li>
</ul>
<p class="image-container"><img style="width: 700.00px" src="img/1b3b28d62721b9e3.png"></p>
<p>Click on the newly created layer and unselect &#34;Fill Color&#34; toggle to see the boundaries of the areas on the map.</p>
<p class="image-container"><img style="width: 700.00px" src="img/85de02821f24aae5.gif"></p>
<p>Similarly you can visualize the <code>GEOLAB.GEOGRAPHY.NL_CABLES_STATIONS</code> table.</p>
<p class="image-container"><img style="width: 700.00px" src="img/19bdb949965fad64.gif"></p>
<p>Now you will create a table with locations of cell towers stored as GEOGRAPHY and enable search optimization, just like for the previous two tables. Run the following query in your Snowflake&#39;s worksheet:</p>
<pre><code>CREATE OR REPLACE TABLE geolab.geography.nl_lte AS
SELECT DISTINCT st_point(lon, lat) AS geom,
                cell_range
FROM OPENCELLID.PUBLIC.RAW_CELL_TOWERS t1
WHERE mcc = &#39;204&#39; -- 204 is the mobile country code in the Netherlands
  AND radio=&#39;LTE&#39;
ORDER BY st_geohash(geom);

ALTER TABLE geolab.geography.nl_lte ADD SEARCH OPTIMIZATION ON GEO(geom); 
</code></pre>
<p>Finally, you will find all cell towers that don&#39;t have an energy line within a 2-kilometer radius. For each cell tower you&#39;ll calculate the distance to the nearest electricity cable. In CARTO Builder click on the Add <code>Source From</code> → <code>Custom Query (SQL)</code> and make sure you have selected the Snowflake Connection that you have created in previous steps.</p>
<p class="image-container"><img style="width: 700.00px" src="img/b3eb977704672d7e.gif"></p>
<p>Then paste the following query and click on the green <code>Run</code> button.</p>
<pre><code>SELECT province_name,
       cells.geom
FROM geolab.geography.nl_lte cells
LEFT JOIN geolab.geography.nl_cables_stations cables 
  ON st_dwithin(cells.geom, cables.geom, 2000)
JOIN geolab.geography.nl_administrative_areas areas 
  ON st_contains(areas.geom, cells.geom)
WHERE areas.type = &#39;Province&#39;
  AND areas.province_name in (&#39;Noord-Brabant&#39;, &#39;Overijssel&#39;, &#39;Limburg&#39;, &#39;Groningen&#39;, &#39;Drenthe&#39;)
  AND cables.geom IS NULL;
</code></pre>
<p>You can modify the colors of cell towers in the output and expand their radius in order to enhance their visibility.</p>
<p class="image-container"><img style="width: 700.00px" src="img/310ea6817361a60f.gif"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Advanced Analysis using Spatial Joins and H3" duration="20">
        <p>In the previous section you&#39;ve found cell towers that don&#39;t have electricity cables nearby. But what about answering more sophisticated questions, like what areas in the Netherlands have very good and bad coverage by LTE (4G) network? You can use geospatial functions combined with spatial join and H3 functions.</p>
<h2 is-upgraded>What municipalities in the Netherlands have good/poor LTE coverage?</h2>
<p>You have been using <code>nl_lte</code> table, which stores the locations of cell towers. To find municipalities in the Netherlands with good and bad coverage by LTE network, you will undertake a two-step process as follows:</p>
<ul>
<li>For every LTE cell tower, you will calculate the coverage area.</li>
<li>For every Dutch municipality, calculate the area covered by the LTE network.</li>
</ul>
<p><code>ST_BUFFER</code> from the Carto toolbox can be used to calculate the coverage area for each LTE cell tower. In the <code>nl_lte</code> table, there is a field <code>cell_range</code> which can be used as a value of radius in <code>ST_BUFFER</code>. For the sake of this example you will assume that a good signal can be received no further than 2000 meters away from the LTE cell.</p>
<p>Run the following two queries in your Snowflake&#39;s worksheet:</p>
<pre><code>CREATE OR REPLACE TABLE geolab.geography.nl_lte_with_coverage AS
SELECT geom,
       cell_range,
       carto.carto.st_buffer(geom, least(cell_range, 2000), 5) AS coverage
FROM geolab.geography.nl_lte
ORDER BY st_geohash(geom);

ALTER TABLE geolab.geography.nl_lte_with_coverage ADD SEARCH OPTIMIZATION ON GEO(geom); 
</code></pre>
<p>Now there is a new column named <code>coverage</code> that contains a polygon representing the area covered by each cell tower&#39;s signal. Let&#39;s create a new map in the CARTO Builder and run the following query to visualize the coverage for one of the municipalities:</p>
<pre><code>SELECT c.coverage AS geom
FROM geolab.geography.nl_lte_with_coverage c
JOIN geolab.geography.nl_administrative_areas b 
  ON st_intersects(b.geom, c.geom)
WHERE TYPE = &#39;Municipality&#39;
  AND municipality_name = &#39;Angerlo&#39;;
</code></pre>
<p>The result of this query is a number of overlapping circles:</p>
<p class="image-container"><img style="width: 700.00px" src="img/727b48d1c2e3c6df.gif"></p>
<p>To calculate the coverage of each district by LTE network, you can create a user-defined Python function that calculates an aggregated union and uses the Shapely library under the hood. Run the following query from Snowflake Worksheets:</p>
<pre><code>CREATE OR REPLACE FUNCTION geolab.geography.py_union_agg(g1 array)
RETURNS GEOGRAPHY
LANGUAGE PYTHON
RUNTIME_VERSION = 3.8
PACKAGES = (&#39;shapely&#39;)
HANDLER = &#39;udf&#39;
AS $$
from shapely.ops import unary_union
from shapely.geometry import shape, mapping
def udf(g1):
    shape_union = unary_union([shape(i) for i in g1])
    shape_union = shape_union.simplify(0.000001)
    return mapping(shape_union)
$$;
</code></pre>
<p>The function above gets an array of spatial objects and returns a single large shape which is a union of all initial shapes. Now run the following query from the CARTO Builder:</p>
<pre><code>SELECT geolab.geography.py_union_agg(array_agg(st_asgeojson(c.coverage))) AS geom
FROM geolab.geography.nl_lte_with_coverage c
JOIN geolab.geography.nl_administrative_areas b 
  ON st_intersects(b.geom, c.geom)
WHERE type = &#39;Municipality&#39;
AND municipality_name = &#39;Angerlo&#39;;
</code></pre>
<p>Note how the result of this function returns a single polygon covering the same area without overlaps.</p>
<p class="image-container"><img style="width: 700.00px" src="img/8a7159d9415eec4c.png"></p>
<p>Let&#39;s now for every municipality compute the following:</p>
<ul>
<li>The area that is covered by the LTE network</li>
<li>The numerical value of coverage ratio by the LTE network</li>
</ul>
<p>Use the table <code>nl_lte_with_coverage</code>, and first join it with <code>nl_administrative_areas</code> using <code>ST_INTERSECTS</code> predicate to match cell towers to the municipalities they cover. Then you use <code>PY_UNION_AGG</code> to get a combined coverage polygon. Then use <code>ST_INTERSECTION</code> to find a portion of the municipality that is covered by the LTE signal. Then you compute the covered area in square meters. The result will be saved in the new table. To speed up queries against that newly created table, you will enable the search optimization feature.</p>
<p>Run the following two queries:</p>
<pre><code>CREATE OR REPLACE TABLE geolab.geography.nl_municipalities_coverage AS
SELECT municipality_name,
       any_value(geom) AS municipality_geom,
       st_intersection(municipality_geom, 
                       geolab.geography.py_union_agg(array_agg(st_asgeojson(coverage)))) AS coverage_geom,
       round(st_area(coverage_geom)/st_area(municipality_geom), 2) AS coverage_ratio
FROM
  (SELECT c.coverage AS coverage,
          b.municipality_name AS municipality_name,
          b.geom
   FROM geolab.geography.nl_lte_with_coverage c
   INNER JOIN geolab.geography.nl_administrative_areas b 
      ON st_intersects(b.geom, c.coverage)
   WHERE TYPE = &#39;Municipality&#39;)
GROUP BY municipality_name
ORDER BY st_geohash(municipality_geom);

ALTER TABLE geolab.geography.nl_municipalities_coverage ADD SEARCH OPTIMIZATION ON GEO(municipality_geom);
</code></pre>
<p>Nice! Now you have a <code>nl_municipalities_coverage</code> table that contains the name of the municipality, the boundaries of that municipality, and the boundaries of the LTE coverage area. Let&#39;s visualize this in Carto. Paste the following query into the SQL editor and use the <code>coverage_ratio</code> column to color code the coverage areas.</p>
<pre><code>SELECT coverage_geom AS geom,
       coverage_ratio
FROM geolab.geography.nl_municipalities_coverage;
</code></pre>
<p class="image-container"><img style="width: 700.00px" src="img/2e280ee86de4fe07.gif"></p>
<h2 is-upgraded>What percent of the Dutch highways have LTE coverage?</h2>
<p>Now imagine you want to calculate what percentage of highways in the Netherlands are covered by the LTE network. To get the number, you can employ the <code>Netherlands Open Map Data</code> dataset that has NL motorways.</p>
<aside class="warning"><p> At this point you need to use Open Street Map data for the Netherlands. If you had to skip importing this table because the data was not ready please go back to that step. The data should be available by now.</p>
</aside>
<p>Run the following query in your Snowflake worksheet:</p>
<pre><code>SELECT sum(st_length(st_intersection(coverage.coverage_geom, roads.geo_cordinates))) AS covered_length,
       sum(st_length(st_intersection(coverage.municipality_geom, roads.geo_cordinates))) AS total_length,
       round(100 * covered_length / total_length, 2) AS &#34;Coverage, %&#34;
FROM osm_nl.netherlands.v_road roads,
     geolab.geography.nl_municipalities_coverage coverage
WHERE st_intersects(coverage.municipality_geom, roads.geo_cordinates)
  AND roads.class in (&#39;primary&#39;, &#39;motorway&#39;);
</code></pre>
<p>It seems your LTE network covers almost 100% of the highways. A good number to call out in a marketing campaign.</p>
<h2 is-upgraded>Estimating the quality of LTE signal on Dutch highways</h2>
<p>In the previous section you found that almost all highways in the Netherlands are within a range of LTE towers. But the LTE signal may have a different quality depending on how close the tower is or how many towers are in reach. The next question you may ask as an analysis is what motorways in the NL have poor signal quality.</p>
<p>For this you need to build a signal decay model. You will use H3 to represent signal distribution around the cell towers.</p>
<p>In the query below, the first CTE uses the <code>H3_POINT_TO_CELL</code> function to compute the H3 cell id for each cell tower. It also estimates the distance in H3 cells around the tower based on the cell&#39;s range. The distance is calculated by dividing the <code>cell_range</code> by 400 meters, which represents the spacing between H3 cells at resolution 9.</p>
<p>Now that you know the H3 cell for each LTE tower you can find its neighboring H3 cells and estimate signal strength in them. First, you will apply the <code>H3_GRID_DISK</code> function to compute all neighboring H3 cells within a certain distance from a given H3 cell. Since <code>H3_GRID_DISK</code> yields an array, you must use the lateral join to flatten these arrays. Then you will create a decay function based on the H3 distance, so you need to determine the maximum H3 distance for each antenna. You can then group the data by H3 cell and choose the highest signal strength within that cell. Multiple towers can cover the same H3 cell multiple times; thus, you will select the one with the strongest signal.</p>
<p>The signal will range from 0 (poor) to 100 (strongest). The model multiplies the &#34;starting signal strength&#34; of 100 by the distance between the antenna and the H3 cell, and it adds more noise as the H3 cell is further away.</p>
<p>Ordering by H3 will enable CARTO to execute queries faster, which is beneficial for visualization purposes.</p>
<p>Run the following query:</p>
<pre><code>CREATE OR REPLACE TABLE geolab.geography.nl_lte_coverage_h3 AS
// First estimate compute H3 cells and estimate number of H3 cells within range
WITH nl_lte_h3 AS (
    SELECT row_number() OVER(ORDER BY NULL) AS id,
           cell_range,
           H3_POINT_TO_CELL(geom, 9)::int AS h3,
           round(least(cell_range, 2000) / 400)::int AS h3_cell_range
    FROM geolab.geography.nl_lte
),
// Find all neighboring cells and calculate signal strength in them
h3_neighbors AS (
  SELECT id,
         p.value::int AS h3,
         H3_GRID_DISTANCE(n.h3, p.value::int) AS H3_GRID_DISTANCE,
         // decay model for signal strength:
         100 * pow(1 - H3_GRID_DISTANCE / (h3_cell_range + 1), 2) AS signal_strength
  FROM nl_lte_h3 n,
       table(flatten(INPUT =&gt; H3_GRID_DISK(n.h3, h3_cell_range))) p)
SELECT h3, 
       // maximum signal strength with noise:
       max(signal_strength) * uniform(0.8, 1::float, random()) AS signal_strength
FROM h3_neighbors
GROUP BY h3
ORDER BY h3;
</code></pre>
<p>Now that you have created your signal decay model, let&#39;s visualize it in CARTO. For that, you can just run the following query from the query console into a new map.</p>
<pre><code>SELECT h3,
       signal_strength
FROM geolab.geography.nl_lte_coverage_h3;
</code></pre>
<aside class="special"><p> Note that you don&#39;t have a <code>GEOGRAPHY</code> on this query. This is because CARTO has native support of H3 and can show the H3 geography representation on the browser without the need to store and move the geography from the database to the browser.</p>
</aside>
<p>As you create an H3 layer you will need to configure the layer type from the query console:</p>
<p class="image-container"><img style="width: 700.00px" src="img/d1c38dc0de2bf966.gif"></p>
<p>H3 layers allow us to show aggregated information at different resolutions for different zoom levels. Because of this, when you style the layer, you need to decide on an aggregation method for the attribute to show, in this example you will use <code>signal_strength</code>.</p>
<p class="image-container"><img style="width: 700.00px" src="img/4b442386f6a20e0b.png"></p>
<p>Remember to select a color palette of your liking and the color scale (the default is custom but you want to <em>Quantize</em> bins for this use case). You can also change the relation between the zoom level and the resolution. The higher the resolution configuration, the more granularity you will see on the map but it will also take longer to load. Select resolution 5.</p>
<p class="image-container"><img style="width: 700.00px" src="img/d8af3dd44b69ac85.gif"></p>
<p>Let&#39;s now use the road network from <code>NL Open Map Data</code> to see which road segments have good coverage and which do not. To intersect the road layer with the H3 signal strength layer you need to find H3 cells covering all motorways in the NL.</p>
<p>The query below demonstrates one way of doing this. First, you split the road geometries into simple segments and compute the H3 index for in the middle of each segment. Then you aggregate all segments back. Run the following query:</p>
<pre><code>CREATE OR REPLACE table geolab.geography.nl_roads_h3 AS 
// import roads from OSM:
WITH roads AS (
  SELECT row_number() over(ORDER BY NULL) AS road_id,
        geo_cordinates AS geom
  FROM OSM_NL.NETHERLANDS.V_ROAD roads
  WHERE class IN (&#39;primary&#39;, &#39;motorway&#39;)
    AND st_dimension(geo_cordinates) = 1
),
// In order to compute H3 cells corresponding to each road you need to first
// split roads into the line segments. You do it using the ST_POINTN function
segments AS (
  SELECT road_id,
          value::integer AS segment_id,
          st_makeline(st_pointn(geom, segment_id), st_pointn(geom, segment_id + 1)) AS SEGMENT,
          geom,
          H3_POINT_TO_CELL(st_centroid(SEGMENT), 9)::int AS h3_center
  FROM roads,
       LATERAL flatten(array_generate_range(1, st_npoints(geom)))) 
// Next table build the H3 cells covering the roads
// For each line segment you find a corresponding H3 cell and then aggregate by road id and H3
// At this point you switched from segments to H3 cells covering the roads.
SELECT road_id,
       h3_center AS h3,
       any_value(geom) AS road_geometry
FROM segments
GROUP BY 1, 2
ORDER BY h3;
</code></pre>
<p>If you visualize table <code>GEOLAB.GEOGRAPHY.NL_ROADS_H3</code> in CARTO Builder (<code>Add Source From</code> → <code>Data Explorer</code>) you will see tessellated roads.</p>
<p class="image-container"><img style="width: 700.00px" src="img/8ea263af014219f4.png"></p>
<p>Now you use the signal decay model that you built previously to estimate the average signal along each highway. For this you need to join two tables (tessellated highways and the signal strength) using H3 cell id and aggregate the result by road id.</p>
<p>Run the following two queries.</p>
<pre><code>CREATE OR REPLACE TABLE geolab.geography.osm_nl_not_covered AS
SELECT road_id,
       any_value(road_geometry) AS geom,
       avg(ifnull(signal_strength, 0.0)) AS avg_signal_strength,
       iff(avg_signal_strength &gt;= 50, &#39;OK Signal&#39;, &#39;No Signal&#39;) AS signal_category
FROM geolab.geography.nl_roads_h3 roads_h3
LEFT JOIN geolab.geography.nl_lte_coverage_h3 cells ON roads_h3.h3 = cells.h3
GROUP BY road_id
ORDER BY st_geohash(geom);

ALTER TABLE geolab.geography.osm_nl_not_covered ADD SEARCH OPTIMIZATION ON GEO(geom);
</code></pre>
<p>Now that you have classified road segments by signal and no signal, you can run the following simple query to get the length of each geography in meters:</p>
<pre><code>SELECT signal_category,
       SUM(ST_LENGTH(geom)/1000)::int AS total_km
FROM geolab.geography.osm_nl_not_covered
GROUP BY signal_category;
</code></pre>
<p>You now know that you have 14,601 km with good coverage and 1,667 with poor/no coverage. Interestingly, that is about 13 % of the NL roads!</p>
<p>Lastly, with this layer, you can add it to your CARTO map and visualize the road segment according to the <code>SIGNAL_CATEGORY</code> feature you created.</p>
<p>For this, you can add the layer via <code>Add source from</code> → <code>Data Explorer</code>. Then select your connection and the <code>GEOLAB.GEOGRAPHY.OSM_NL_NOT_COVERED</code> table.</p>
<p class="image-container"><img style="width: 700.00px" src="img/64af56a42ce4f1a6.png"></p>
<p>Once you have your second layer on the map, you can click on it to style it and show the stroke color based on your <code>SIGNAL_CATEGORY</code> column. To do that, create a &#34;Custom palette&#34; with just two colors: gray for roads with good signal and red for roads with no/poor signal.</p>
<p class="image-container"><img style="width: 700.00px" src="img/abde289037d75a3e.gif"></p>
<aside class="special"><p> You may feel that these last several queries were a bit long and repetitive, but remember that the intention of this guide was to walk you through the progression of building these longer, more complicated queries by illustrating to you what happens at each step through the progression. By understanding how functions can be combined, it helps you to understand how you can do more advanced things with Snowflake geospatial features!</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Conclusion" duration="0">
        <p>In this guide, you acquired geospatial data from the Snowflake Marketplace, explored how the GEOMETRY data type works and how it differs from the GEOGRAPHY. You converted one data type into another and queried geospatial data using parser, constructor, transformation, calculation and H3 functions on single tables and multiple tables with joins. You then saw how geospatial objects could be visualized using CARTO.</p>
<p>You are now ready to explore the larger world of Snowflake geospatial support and geospatial functions.</p>
<h2 class="checklist" is-upgraded>What we&#39;ve covered</h2>
<ul class="checklist">
<li>How to acquire a shared database from the Snowflake Marketplace and from External and internal storages.</li>
<li>The GEOMETRY data type, its formats GeoJSON, WKT, EWKT, WKB, and EWKB, and how to switch between them.</li>
<li>How to use constructors like TO_GEOMETRY, ST_MAKELINE.</li>
<li>How to reproject between SRIDs using ST_TRANSFORM.</li>
<li>How to perform relational calculations like ST_DWITHIN and ST_INTERSECTS.</li>
<li>How to perform measurement calculations like ST_LENGTH.</li>
<li>How to use set operations like ST_INTERSECTION.</li>
<li>How to use Python UDFs for reading Shapefiles and creating custom functions.</li>
<li>How to use Spatial grid and H3 functions like H3_POINT_TO_CELL, H3_GRID_DISK, H3_POLYFILL.</li>
<li>How to use Search Optimization to speed up geospatial queries.</li>
</ul>
<h2 is-upgraded>Related Resources</h2>
<ul>
<li><a href="https://quickstarts.snowflake.com/guide/geospatial_analytics_with_snowflake_and_carto_ny/index.html" target="_blank">Geospatial Analytics for Retail with Snowflake and CARTO</a></li>
<li><a href="https://quickstarts.snowflake.com/guide/geo_analysis_telecom/index.html" target="_blank">Geospatial Analytics for Telecom with Snowflake and CARTO</a></li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/native-shim.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/custom-elements.min.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/prettify.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>
  <script type="text/javascript">
    window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var r=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(r?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["addEventProperties","addUserProperties","clearEventProperties","identify","removeEventProperty","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
    heap.load("2025084205");
  </script>
</body>
</html>
