
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Accelerating Data Teams with dbt Cloud &amp; Snowflake</title>

  
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5Q8R2G');</script>
  

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-08H27EW14N"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-08H27EW14N');
</script>

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q8R2G"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  
  <google-codelab-analytics gaid="UA-41491190-9"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="data_teams_with_dbt_cloud"
                  title="Accelerating Data Teams with dbt Cloud &amp; Snowflake"
                  environment="web"
                  feedback-link="https://github.com/Snowflake-Labs/sfguides/issues">
    
      <google-codelab-step label="Overview" duration="1">
        <p>Modern businesses need modern data strategies, built on platforms that support agility, growth and operational efficiency.</p>
<p><a href="https://signup.snowflake.com/?utm_source=google&utm_medium=paidsearch&utm_content=go-eta-ld-free-trial&utm_term=c-g-snowflake-e&utm_campaign=na-en-Branded&_bt=470247374327&_bk=snowflake&_bm=e&_bn=g&_bg=64805047909&gclid=Cj0KCQjw18WKBhCUARIsAFiW7JwA-C_HmNQzG_OFKhM1Hn9vlW6EAs-9mveiMXychVbbK34lh4vGfHsaAv4NEALw_wcB&gclsrc=aw.ds" target="_blank">Snowflake</a> is the Data Cloud, a future-proof solution that simplifies data pipelines, so you can focus on data and analytics instead of infrastructure management.</p>
<p><a href="https://www.getdbt.com/" target="_blank">dbt</a> is a transformation workflow that lets teams quickly and collaboratively deploy analytics code following software engineering best practices like modularity, portability, CI/CD, and documentation. Now anyone who knows SQL can build production-grade data pipelines. It transforms data in the warehouse, leveraging cloud data platforms like Snowflake.</p>
<p>In this Quickstart, you will follow a step-by-step guide to using dbt with Snowflake, and see some of the benefits this tandem brings.</p>
<p>Let&#39;s get started.</p>
<h2 is-upgraded>What You&#39;ll Use During the Lab</h2>
<ul>
<li>A trial <a href="https://trial.snowflake.com/" target="_blank">Snowflake account</a> with <code>ACCOUNTADMIN</code> access</li>
<li>A <a href="https://www.getdbt.com/signup/" target="_blank">dbt Cloud account</a></li>
</ul>
<h2 class="checklist" is-upgraded>What You&#39;ll Learn</h2>
<ul class="checklist">
<li>How to build scalable data transformation pipelines using dbt &amp; Snowflake</li>
<li>How to leverage data in Snowflake&#39;s Data Marketplace</li>
</ul>
<h2 is-upgraded>What You&#39;ll Build</h2>
<ul>
<li>A set of data analytics pipelines for Financial Services data leveraging dbt and Snowflake, making use of best practices like data quality tests and code promotion between environments</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Architecture and Use Case Overview" duration="1">
        <p>In this lab, we are going to analyze the historical trading performance of a company that has trading desks spread across different regions. As inputs, we are going to leverage datasets available in Knoema Economy Data Atlas, which is available in Snowflake Marketplace. We&#39;ll also make use of a few manual uploads. To do this, we are going to set up the environments, build scalable pipelines in dbt, establish data tests , and promote code to production.</p>
<p class="image-container"><img alt="Architecture Overview" src="img/f6f4766b52a27108.png"></p>
<p>Just to give you a sneak peek, this is the data lineage we will be creating using dbt.</p>
<p>Stay tuned!</p>
<p class="image-container"><img alt="DAG" src="img/619556ba8674abb2.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Snowflake Configuration" duration="1">
        <ol type="1">
<li>Login to your Snowflake trial account.<br><img alt="Snowflake Log In Screen" src="img/25919102cc7730a4.png"></li>
<li>UI Tour (SE will walk through this live). For post-workshop participants, click <a href="https://docs.snowflake.com/en/user-guide/snowflake-manager.html#quick-tour-of-the-web-interface" target="_blank">here</a> for a quick tour of the UI.</li>
</ol>
<p>We will be using the new UI to getting started but you can also switch over to the Classic Console if you would like. It will not affect your dbt experience but may change where the buttons are in the Snowflake UI.</p>
<p>New UI: <img alt="New Snowflake UI" src="img/8179fbbefc05bbf1.png"></p>
<p>Classic UI:</p>
<p><img alt="Snowflake Worksheets" src="img/a9e4874ee1809003.png"><br> If you ever want to change from the new UI to the classic one, click on the home button and then <code>Classic Console</code></p>


      </google-codelab-step>
    
      <google-codelab-step label="Connect to Data Source" duration="5">
        <p>Now we need to obtain our raw data. We are going to the Snowflake Marketplace to connect to the Knoema dataset.</p>
<ol type="1">
<li>We want to go into the Snowflake Marketplace to connect to the Knoema dataset. Click on Data on the left hand sidebar and then Marketplace.</li>
</ol>
<p class="image-container"><img alt="Click on Marketplace" src="img/8b1a6f4d7c7bf458.png"></p>
<ol type="1" start="2">
<li>Now let&#39;s look for Knoema Economy Atlas Data. Type into the &#34;Search Data Marketplace&#34; search bar &#34;Knoema Economy Atlas Data&#34;.  Find the Knoema Economy Atlas Data tile in the results. Once you find it, click on it.</li>
</ol>
<p class="image-container"><img alt="Click on Knoema Tile" src="img/76cb43b0f2a808c2.png"></p>
<ol type="1" start="6">
<li>You should now on a page with a description of the data, sample queries, and other useful information. Let&#39;s get this data into our Snowflake account. Click the &#34;Get Data&#34; button.</li>
</ol>
<p class="image-container"><img alt="Click on Get Data" src="img/a869b2bf88892059.png"></p>
<ol type="1" start="7">
<li>In the pop-up, enter &#34;KNOEMA_ECONOMY_DATA_ATLAS&#34; as the database name and click &#34;Get Data&#34;. Do not forget to update the name of the database or you will have update some code down the line.</li>
</ol>
<p class="image-container"><img alt="Rename Database" src="img/9531b7be6a185d9.png"></p>
<p>So what is happening here? Knoema has granted access to this data from their Snowflake account to yours. You&#39;re creating a new database in your account for this data to live - but the best part is that no data is going to move between accounts! When you query, you&#39;ll really be querying the data that lives in the Knoema account. If they change the data, you&#39;ll automatically see those changes. No need to define schemas, move data, or create a data pipeline either.</p>
<ol type="1" start="8">
<li>Click on Query Data.</li>
</ol>
<p class="image-container"><img alt="Click on Query Data" src="img/3d5d54ded7038c1d.png"></p>
<ol type="1" start="9">
<li>Now let&#39;s look at the new data. On the left hand sidebar, you should see KNOEMA_ECONOMY_DATA_ATLAS listed as a database. If not, refresh the UI and check again.</li>
<li>Now let&#39;s try to query the data. If you want to switch back to the original interface, you can click on the home button on the top left and then <code>Classic Console</code> on the bottom of the left hand sidebar. This will port you back where you can see the database displayed the way it was before.</li>
</ol>
<p>The Economy Atlas comes with more than 300 datasets. In order to improve navigation, the data provider has kindly supplied a table called DATASETS. Let&#39;s go ahead and find the ones related to the stock history and currency exchange rates that we are going to use in the next step.</p>
<ol type="1" start="11">
<li>Remove the code in the worksheet and paste in this code.</li>
</ol>
<pre><code language="language-sql" class="language-sql">select * 
  from &#34;KNOEMA_ECONOMY_DATA_ATLAS&#34;.&#34;ECONOMY&#34;.&#34;DATASETS&#34;
 where &#34;DatasetName&#34; ILIKE &#39;US Stock%&#39;
    OR &#34;DatasetName&#34; ILIKE &#39;Exchange%Rates%&#39;;
</code></pre>
<p class="image-container"><img alt="Query Knoema" src="img/3e834bf5607cd561.png"></p>
<ol type="1" start="12">
<li>Now we can see what our datasets names are, let&#39;s try to query one of the datasets:</li>
</ol>
<pre><code language="language-sql" class="language-sql">select * 
  from KNOEMA_ECONOMY_DATA_ATLAS.ECONOMY.USINDSSP2020
 where &#34;Date&#34; = &#39;2020-02-03&#39;;
</code></pre>
<p class="image-container"><img alt="Query Knoema" src="img/4aa7bce6e0404b06.png"></p>
<p>Congratulations! You successfully tapped into a live data feed of Trade and FX rates data with NO ETL involved. Isn&#39;t this cool? Now let&#39;s start building our pipelines.</p>


      </google-codelab-step>
    
      <google-codelab-step label="dbt Configuration" duration="2">
        <p>Now it&#39;s time to set up dbt. We are going to be using <a href="https://docs.snowflake.com/en/user-guide/ecosystem-partner-connect.html" target="_blank">Snowflake Partner Connect</a> to set up your dbt Cloud account and project. Using this method will allow you to spin up a fully fledged dbt account with your <a href="https://docs.getdbt.com/docs/dbt-cloud/cloud-configuring-dbt-cloud/connecting-your-database#connecting-to-snowflake" target="_blank">Snowflake connection</a>, <a href="https://docs.getdbt.com/docs/dbt-cloud/cloud-configuring-dbt-cloud/cloud-using-a-managed-repository" target="_blank">managed repository</a>, <a href="https://docs.getdbt.com/docs/guides/managing-environments" target="_blank">environments</a>, and credentials in minutes.</p>
<ol type="1">
<li>In the Snowflake UI, click on the home icon on the top left side. To access Partner Connect, click on your user and then Partner Connect. Make sure you&#39;re still set as the ACCOUNTADMIN role.</li>
</ol>
<p class="image-container"><img alt="Click on Partner Connect" src="img/9b35b63baff3a831.png"></p>
<p>If you&#39;re using the classic console, it will be on the top right. <img alt="Click on Partner Connect" src="img/4834f675346d24df.png"></p>
<ol type="1" start="2">
<li>Find the dbt Tile by typing into the &#34;Search Partner Connect&#34; search bar. Click on the dbt tile.</li>
<li>You should now see a popup that says <code>Connect to dbt</code>. Click on <code>Optional Grant</code> and you are going to add in the KNOEMA_ECONOMY_DATA_ATLAS database. This will grant access for your new dbt user role to the database.</li>
<li>Click on <code>Connect</code>. This will create a dedicated dbt user, database, warehouse, and role for your dbt Cloud trial.</li>
</ol>
<p class="image-container"><img alt="Click on Connect" src="img/2e72af80f8e517c4.png"></p>
<ol type="1" start="5">
<li>When the popup that says &#34;Your partner account has been created&#34;, click on activate. <img alt="Click on Partner Activate" src="img/7caf37d48ae26027.png"></li>
<li>You should be redirected to a dbt Cloud registration page. Fill out the form. Make sure to save the password somewhere for login in the future.</li>
</ol>
<p class="image-container"><img alt="Register dbt Cloud account" src="img/836c7a78edc4093e.png"></p>
<ol type="1" start="7">
<li>Click on Compete Registration. You should now be redirected to your dbt Cloud account, complete with a connection to your Snowflake account, a deployment and a development environment, and even a sample job.</li>
</ol>
<p>To help you version control your dbt project, we have connected it to a <a href="https://docs.getdbt.com/docs/dbt-cloud/cloud-configuring-dbt-cloud/cloud-using-a-managed-repository" target="_blank">managed repository</a>, which means that dbt Labs will be hosting your repository for you. This will give you access to a git workflow without you having to create and host the repository yourself. You will not need to know git for this workshop; dbt Cloud will help guide you through the workflow. In the future, when you&#39;re developing your own project, feel free to use <a href="https://docs.getdbt.com/docs/dbt-cloud/cloud-configuring-dbt-cloud/cloud-installing-the-github-application" target="_blank">your own repository</a>. This will allow you to play with features like <a href="https://docs.getdbt.com/docs/dbt-cloud/using-dbt-cloud/cloud-enabling-continuous-integration-with-github" target="_blank">Slim CI</a> builds after this workshop.</p>


      </google-codelab-step>
    
      <google-codelab-step label="dbt Project Configuration" duration="5">
        <ol type="1">
<li>Now let&#39;s set up our dbt project. Click on the hamburger menu on the top left side and click on <code>Develop</code>.  This will spin up your IDE (Integrated Development Environment) where you will be developing your dbt Project.</li>
</ol>
<p class="image-container"><img alt="Click on the hamburger" src="img/743ced9ac9218105.png"><img alt="Click on the develop" src="img/d36ddb9756ec1db.png"></p>
<ol type="1" start="2">
<li>After the IDE loads, click <code>Initialize your project</code> to set up your dbt project. Once you click on it, dbt will generate our starter project with the core files and folders. <img alt="Click on the Initialize" src="img/a3b8e171641b262a.png"></li>
<li>You should see new files and folders created in your file tree. These are all the files and folders you will need for a dbt project. Take a look around, especially at the <a href="https://docs.getdbt.com/reference/dbt_project.yml" target="_blank">dbt_project.yml</a> and what&#39;s in the <a href="https://docs.getdbt.com/docs/building-a-dbt-project/building-models" target="_blank">models</a> directory.</li>
<li>Click <code>Commit</code>. Enter a commit message, and then click <code>Commit</code> again to commit your work to your master branch.</li>
</ol>
<p class="image-container"><img alt="Click on the commit" src="img/d894e24773b47eca.png"><img alt="commit message" src="img/fe6b013fcf37dbdb.png"></p>
<p>Commit messages should always be indicative of the work you are saving. This helps you create a reference point for the future in case of auditing and debugging.  By <a href="https://www.atlassian.com/git/tutorials/saving-changes/git-commit#:~:text=The%20git%20commit%20command%20captures,you%20explicitly%20ask%20it%20to." target="_blank">committing</a>, you are saving to a remote branch in Github. This will also be the only time you will save straight to your master branch (which is the main branch). We always want to create a degree of separation from development work and your production branch.</p>
<ol type="1" start="6">
<li>Click <code>create new branch</code> to check out a new git branch to start developing. <img alt="create branch" src="img/c76ec8fae2794a1e.png"></li>
<li>Name the branch &#34;dbt_snowflake_workshop&#34; and click <code>Submit</code>. <img alt="name branch" src="img/36bc6b7917d57390.png"></li>
<li>UI walkthrough (SA will walk through during the workshop). Post workshop, users can look at <a href="https://getdbt.wistia.com/medias/0828jynq3v" target="_blank">this video for the walkthrough</a>.</li>
<li>Now let&#39;s validate that everything was initialized correctly by running the sample models that come with the starter dbt project.</li>
<li>Type in <code>dbt run</code> on the command line at the bottom, and click <code>Enter</code>. The command line is where you will be entering in dbt commands to execute dbt actions.</li>
</ol>
<p>If you want to see the actual code being executed, you can go into the ‘Details&#39; tab next to <code>Summary</code> and look through the logs. Here you can see that dbt is writing the DDL for you, allowing you to focus on just writing the SQL select statement.</p>
<p class="image-container"><img alt="dbt run" src="img/235dfcd5cc82494a.png"></p>
<ol type="1" start="11">
<li>The output should look like below, confirming dbt was able to connect to Snowflake and successfully execute the sample models in the models folder:</li>
</ol>
<p class="image-container"><img alt="successful run" src="img/14453157084ea6b9.png"></p>
<ol type="1" start="12">
<li>If you want to see what is executed against Snowflake, click into one of the model tabs and click on details. You will see the log of the compiled code and how dbt interacted with Snowflake. Note that dbt by default built all of your models into this development schema made up of your first initial and last name. We will cover more environments later on.</li>
</ol>
<p class="image-container"><img alt="successful run" src="img/f922a258819206f8.png"></p>
<ol type="1" start="13">
<li>Now let&#39;s visually confirm the objects in Snowflake. Switch to the Snowflake UI (classic console) and refresh database objects. Expand the database <code>PC_DBT_WH</code>. Then the development schema with your first initial and last name. And lastly Tables and Views. You should see the table <code>MY_FIRST_DBT_MODEL</code>  and the view <code>MY_SECOND_DBT_MODEL</code>.</li>
</ol>
<p class="image-container"><img alt="successful run" src="img/299fd7e9642a3a88.png"></p>
<p>Congratulations! You just ran your first dbt models on Snowflake!</p>
<p>We are going to start by adding a few more things to our dbt project configuration in order to improve maintainability.</p>
<ol type="1" start="14">
<li>Let&#39;s add in some folders to follow our dimensional modeling structure. To learn more about how we structure our project, <a href="https://discourse.getdbt.com/t/how-we-structure-our-dbt-projects/355" target="_blank">check out this discourse post</a>.  To add new folders, ghost over the models directory in the file tree and click on the ‘...&#39; on the right next to the models directory. Click on &#34;New Folder&#34; and type into it &#34;staging&#34;. Click &#34;Create&#34; after you finish typing and you should see a new folder in the file tree.</li>
</ol>
<p class="image-container"><img alt="create folder" src="img/53e3f249e0e18a3a.png"><img alt="create folder" src="img/9ece2656acb74f5d.png"><img alt="create folder" src="img/6fdd1ec32cd93a5b.png"><img alt="create folder" src="img/8aef6df671963301.png"></p>
<ol type="1" start="15">
<li>Now that you&#39;ve gotten one completed, let&#39;s go ahead and create three more folders. First create a folder named &#34;knoema&#34; in the staging model by clicking on the ‘...&#39; next to the staging folder. This will be where we will put our staging models specific to our knoema source.</li>
<li>Now for our last folders, we are actually going to create two folders at once. Click on the ‘...&#39; next to models again. This time, we are going to fill the file path as &#34;models/marts/core&#34;. This will create a new folder under models called marts and in it, a folder called core.</li>
</ol>
<p>You should have a file tree that looks like this after completing this task.</p>
<p class="image-container"><img alt="create folder" src="img/76d38060aedf8311.png"></p>
<ol type="1" start="17">
<li>Next, let&#39;s update the <a href="https://docs.getdbt.com/reference/dbt_project.yml" target="_blank">dbt_project.yml file</a>. This is a file that tells dbt that the repository is a dbt project as well as how to operate on your project. Click on the file <code>dbt_project.yml</code>. The first thing we are going to do is update the project name from &#34;my_new_project&#34; to &#34;&lt;your_name&gt;_dbt_workshop&#34; at line 5. This will personalize the project a little, and make it yours.</li>
</ol>
<p>Do not forget to save after you have updated the file! This means you will want to either click save or use cmd+s (mac)/ctrl+s(pc). The IDE will also warn you with the teal button on the tab.</p>
<p class="image-container"><img alt="update project" src="img/b40022f8e8d6e895.png"></p>
<ol type="1" start="18">
<li>Now let&#39;s update the models section in the file by declaring our new folders and their model configurations. We will be declaring the default <a href="https://docs.getdbt.com/docs/building-a-dbt-project/building-models/using-custom-schemas" target="_blank">schema</a> that dbt builds the object into, the default <a href="https://docs.getdbt.com/docs/building-a-dbt-project/building-models/materializations" target="_blank">materialization</a>, and disabling any unnecessary models from a run. All of these configurations can be overridden by model configurations on the model file. If a schema is not declared via a configuration, dbt will build into the default schema declared on our development credentials.</li>
</ol>
<p>Copy code below and paste into line 34 to line 38. Remember to replace &lt;your_name&gt;.</p>
<pre><code language="language-yml" class="language-yml">models:
  &lt;your_name&gt;_dbt_workshop:
      example:
          schema: example 
      staging:
          schema: staging
          materialized: view
      marts:
          schema: marts
          materialized: table
</code></pre>
<ol type="1" start="19">
<li>Save the file.</li>
<li>Be sure to click on &#34;Commit&#34; using the git command button (just in case your computer spontaneously explodes into a blob of smoke and melted plastic) to save your work. And supply a good commit message that conveys what you are saving!</li>
<li>To better understand how schema names work in dbt, let&#39;s take a look at the standard <a href="https://docs.getdbt.com/docs/building-a-dbt-project/jinja-macros" target="_blank">macro</a> that <a href="https://docs.getdbt.com/docs/building-a-dbt-project/building-models/using-custom-schemas" target="_blank">dbt uses to define what schema to build your object into</a>. By default, dbt is generating a schema name by appending it to the target schema environment name(dev, prod). If you ever want to override this, you are going to create a new file in the macros folder named <code>generate_schema_name.sql</code>.</li>
</ol>
<p class="image-container"><img alt="schema macro" src="img/d1c85515f81c69e1.png"></p>
<ol type="1" start="22">
<li>Copy and paste the below code into file generate_schema_name.sql to generate the macro.</li>
</ol>
<pre><code language="language-sql" class="language-sql">{% macro generate_schema_name(custom_schema_name, node) -%}

    {%- set default_schema = target.schema -%}
    {%- if custom_schema_name is none -%}

        &#123;&#123; default_schema }}

    {%- else -%}

        &#123;&#123; default_schema }}_&#123;&#123; custom_schema_name | trim }}

    {%- endif -%}

{%- endmacro %}

</code></pre>
<p class="image-container"><img alt="schema macro" src="img/437c9ffdf2cc8a2f.png"></p>
<ol type="1" start="23">
<li>Click Save</li>
<li>To see this macro in action, do another <code>dbt run</code> on the command line. Note how the schema has changed to be appending the custom schema name to our default schema per our macro. You can add in more <a href="https://docs.getdbt.com/docs/building-a-dbt-project/building-models/using-custom-schemas#jinja-context-available-in-generate_schema_name" target="_blank">conditionals</a> to fit your own needs in terms of environment promotions.</li>
</ol>
<p>In this workshop, we will show you how different configurations can easily change how and where your dbt project reads and writes from without needing you to change your code with code promotion.</p>
<p>Macros are a way to do this. Macros are written in a pythonic templating language called <a href="https://docs.getdbt.com/docs/building-a-dbt-project/jinja-macros" target="_blank">Jinja</a>. Jinja allows you to do things that normally aren&#39;t possible in SQL such as create control structures (like if statements and for loops) or abstract away snippets of SQL into reusable functions applicable throughout your project. Jinja helps you write <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank">DRY</a> code in a language that is generally wet.</p>
<p>In this generate_schema_name macro, we are defining what schema your objects should be built into based on the conditionals specified. Going through the macro, what is happening here:</p>
<pre><code language="language-sql" class="language-sql">   {%- set default_schema = target.schema -%}
    {%- if custom_schema_name is none -%}
 
        &#123;&#123; default_schema }}
</code></pre>
<p>Is that we are defining our default schema as the target database and schema defined for your development environment. The Partner Connect flow sets up our development environment to point to the partner connect created database and a schema made of your first initial and last name. You can verify this in your <a href="https://cloud.getdbt.com/#/profile" target="_blank">profile</a>. However, if a custom schema is provided as we did in our dbt_project.yml file, dbt will build into a schema that is a concatenation of our default schema and the custom schema name due to this logic:</p>
<pre><code language="language-sql" class="language-sql">{%- else -%}

    &#123;&#123; default_schema }}_&#123;&#123; custom_schema_name | trim }}

{%- endif -%}
</code></pre>
<p>All of this logic is defined in one place and will be applied on your project which makes it simple to scale up your project, especially as business needs arise.</p>
<p>Later on, we will learn how to use macros from a package and see how those macros help us write SQL quickly.</p>
<ol type="1" start="25">
<li>Now we need to apply another operational macro. This time, this macro will add a <a href="https://docs.getdbt.com/reference/resource-configs/snowflake-configs#query-tags" target="_blank">query tag</a> for every dbt run in the Snowflake history.  To do this, we&#39;ll create a file in the &#34;macros&#34; folder called <code>query_tag.sql</code>.</li>
<li>Copy and paste the following code. This provides the ability to add an additional level of transparency by automatically setting Snowflake query_tag to the name of the model it is associated with.</li>
</ol>
<pre><code language="language-sql" class="language-sql">{% macro set_query_tag() -%}
  {% set new_query_tag = model.name %} {# always use model name #}
  {% if new_query_tag %}
    {% set original_query_tag = get_current_query_tag() %}
    &#123;&#123; log(&#34;Setting query_tag to &#39;&#34; ~ new_query_tag ~ &#34;&#39;. Will reset to &#39;&#34; ~ original_query_tag ~ &#34;&#39; after materialization.&#34;) }}
    {% do run_query(&#34;alter session set query_tag = &#39;{}&#39;&#34;.format(new_query_tag)) %}
    &#123;&#123; return(original_query_tag)}}
  {% endif %}
  &#123;&#123; return(none)}}
{% endmacro %}

</code></pre>
<ol type="1" start="27">
<li>Click &#34;Save&#34;.</li>
</ol>
<p class="image-container"><img alt="query tags" src="img/41a4d5c2e6164be3.png"></p>
<ol type="1" start="28">
<li>Now, do a <code>dbt run</code> again on the command line.</li>
<li>To see where the query tags are applied, go to the Snowflake UI, click the &#34;History&#34; icon on top. You are going to see all the SQL queries you&#39;ve run on your Snowflake account (successful, failed, running etc.). and clearly see which dbt model a  particular query is related to.</li>
</ol>
<p class="image-container"><img alt="query tags" src="img/2da5145f6e90e7b9.png"></p>
<p>Update the Filter to the user is PC_DBT_USER and the status is Succeeded to see the same view as the screenshot above, you can also remove extra columns by clicking on the arrow after hovering over a column, hovering over &#34;Columns&#34; and unchecking any columns you don&#39;t want.</p>
<ol type="1" start="30">
<li>Now we are going to install a dbt package. A dbt <a href="https://docs.getdbt.com/docs/building-a-dbt-project/package-management" target="_blank">package</a> is essentially a dbt project that you can install onto your own dbt project to gain access to the code and use it as your own. Many of our packages are hosted on the <a href="https://hub.getdbt.com/" target="_blank">dbt Packages Hub</a>. In our lab, we are going to demonstrate how to use some useful macros in the dbt_utils package to write some complex SQL. To install it, create a file called <code>packages.yml</code> at the same level as your <code>dbt_project.yml</code> file.</li>
</ol>
<p class="image-container"><img alt="packages" src="img/ba188714cb524399.png"></p>
<ol type="1" start="31">
<li>Copy and paste the following code into file packages.yml.</li>
</ol>
<pre><code language="language-yml" class="language-yml">packages:
  - package: dbt-labs/dbt_utils
    version: 0.8.0
</code></pre>
<p class="image-container"><img alt="packages" src="img/39676f23a14a1c5b.png"></p>
<ol type="1" start="32">
<li>Click <code>Save</code>.</li>
<li>Now we are going to install the package. By running <code>dbt deps</code>, you tell dbt to install the packages. With a successful run, you can check out the dbt_modules folder to see what packages you have installed and the code that is now available to you. <img alt="packages" src="img/abb41b971e3f10d0.png"></li>
<li>Last thing to do before we save our work. Remove the example subdirectory configuration in the <code>dbt_project.yml</code> file and delete the example folder with the models in it.</li>
<li>Click <code>Commit</code> to commit your work!</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Building dbt Data Pipelines" duration="1">
        <p>Now we start to get into the fun stuff. In the next few sections, we are going to build our dbt pipelines. This will include transformations that define these these areas of interest:</p>
<ul>
<li>Stock trading history</li>
<li>Currency exchange rates</li>
<li>Trading books</li>
<li>Profit &amp; Loss calculation</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="dbt pipelines - Sources &amp; Staging" duration="5">
        <h3 is-upgraded>Setting up our Sources</h3>
<ol type="1">
<li>Now let&#39;s head back to the dbt Cloud IDE. We are going to start building our pipelines by declaring our <a href="https://docs.getdbt.com/docs/building-a-dbt-project/using-sources" target="_blank">dbt sources</a>.  Create a <code>knoema_sources.yml</code> file in the staging/knoema folder.</li>
<li>Paste in the following code.</li>
</ol>
<pre><code language="language-yml" class="language-yml">version: 2

sources:
  - name: knoema_economy_data_atlas
    database: knoema_economy_data_atlas
    schema: economy
    tables:
      - name: exratescc2018
      - name: usindssp2020
</code></pre>
<p class="image-container"><img alt="sources" src="img/3eba45ceca02a4.png"></p>
<p>As you might remember, these two objects were mentioned in the Knoema Dataset Catalog table: daily exchange rates and daily US trading history accordingly.</p>
<ol type="1" start="3">
<li>Click <code>Commit</code> and provide a good commit message like &#34;set up knoema source file&#34;. We are going to keep building that muscle of saving your work as you develop.</li>
</ol>
<p>Now we have defined the sources that we will be building our dbt models on top of. By declaring these, we are able to create lineage from our raw objects to our transformed objects and apply documentation and testing.</p>
<h3 is-upgraded>Setting up our Staging Models</h3>
<ol type="1" start="4">
<li>Now let&#39;s create staging models to clean up our raw objects. Staging models bear a one-to-one relationship with the source data table they represent. They have the same granularity, but the columns have been renamed, recast, or reconsidered in some way to follow a consistent, useful format. By creating these as the first level transformation, you can create a consistent foundation to build more complex transformations upon. To learn more, check out our <a href="https://discourse.getdbt.com/t/how-we-structure-our-dbt-projects/355#data-transformation-101-1" target="_blank">discourse post</a>. The first staging model we are going to make will be for exratescc2018. Create a new file in the staging/knoema folder named <code>stg_knoema_fx_rates.sql</code>.</li>
<li>Paste the following select statement.</li>
</ol>
<p>(To learn more about our recommendations around coding style, <a href="https://github.com/dbt-labs/corp/blob/master/dbt_style_guide.md#ctes" target="_blank">check out this repository.</a>)</p>
<pre><code language="language-sql" class="language-sql">with source as (
 
    select * from &#123;&#123;source(&#39;knoema_economy_data_atlas&#39;,&#39;exratescc2018&#39;) }}
 
), 
 
renamed as (
 
select 
 
    &#34;Currency&#34; as currency,
    &#34;Currency Unit&#34; as currency_unit,
    &#34;Frequency&#34; as frequency,
    &#34;Date&#34; as exchange_date,
    &#34;Value&#34; as exchange_value,
    &#34;Indicator&#34; as indicator,
    &#34;Indicator Name&#34; as indicator_name,
    &#39;Knoema.FX Rates&#39; as data_source_name
 
from source 
 
) 
 
select * from renamed
 
</code></pre>
<ol type="1" start="6">
<li>Save the file. To check the query before executing the code against the warehouse, you can click on the <code>Preview</code> button. You can also click on <code>Compile</code> to see the compiled code that will be executed.</li>
</ol>
<p class="image-container"><img alt="staging" src="img/777bf07838345f33.png"></p>
<p>In the compiled code, you will notice that the source function (&#123;&#123;source(‘knoema_economy_data_atlas&#39;,‘exratescc2018&#39;)}})  compiles to the actual database object.</p>
<p>Let&#39;s talk more about this function:</p>
<p>Using the sources function allows you to:</p>
<ul>
<li>Tell dbt how a model relates to its source and then dynamically generate a DAG from this, as you can see in the lineage tab</li>
</ul>
<p class="image-container"><img alt="staging" src="img/3ce1468ead5c8e35.png"></p>
<ul>
<li>This also allows dbt to dynamically replace the sources with their <a href="https://docs.getdbt.com/reference/dbt-jinja-functions/target" target="_blank">target-specific name</a>, whether it&#39;s from the configuration in sources.yml or from the environment. This allows you to promote the same code from dev to prod and any other environments without having to change the code. You can even use the <a href="https://docs.getdbt.com/reference/dbt-jinja-functions/target#use-targetname-to-change-your-source-database" target="_blank">target jinja function</a> to conditionally point to different databases based on the declared target.</li>
</ul>
<ol type="1" start="7">
<li>Now to make the other staging model. Create the file in the same folder and name it <code>stg_knoema_stock_history.sql</code>.</li>
<li>Paste in this code and save.</li>
</ol>
<pre><code language="language-sql" class="language-sql">with source as (

    select * from &#123;&#123;source(&#39;knoema_economy_data_atlas&#39;,&#39;usindssp2020&#39;)}}
), 

renamed as (

    select 

        &#34;Company&#34; as company,
        &#34;Company Name&#34; as company_name,
        &#34;Company Ticker&#34; as company_symbol,
        &#34;Stock Exchange&#34; as stock_exchange,
        &#34;Stock Exchange Name&#34; as stock_exchange_name,
        &#34;Indicator&#34; as indicator,
        &#34;Indicator Name&#34; as indicator_name,
        &#34;Units&#34; as units,
        &#34;Scale&#34; as scale, 
        &#34;Frequency&#34; as frequency, 
        &#34;Date&#34; as stock_date,
        &#34;Value&#34; as stock_value,
        &#39;Knoema.Stock History&#39; as data_source_name 

    from source 

) 

select * from renamed
</code></pre>
<ol type="1" start="9">
<li>Now let&#39;s create these views in Snowflake. Since we only want to run the models in the staging folder, we are going to use the following command on the command line:</li>
</ol>
<p><code>dbt run --select staging.*</code></p>
<p>This allows us to be selective and only run the models in the staging folder. <a href="https://docs.getdbt.com/reference/node-selection/syntax" target="_blank">Node selectors</a> are very helpful in refining what we actually want to run and test.</p>
<p class="image-container"><img alt="staging" src="img/5c03f026374a4e5b.png"></p>
<ol type="1" start="10">
<li>Once everything ran successfully, let&#39;s save our work to our remote branch. Click on <code>Commit</code> and provide a good commit message like &#34;set up staging models&#34;</li>
<li>Now we can go and query this dataset to take a feel of what the data profile looks like. You can either put this query in the &#34;Statement 1&#34; tab or in Snowflake UI. Remember to change the schema name to the correct one for you.</li>
</ol>
<pre><code language="language-sql" class="language-sql">select * 
  from pc_dbt_db.&lt;dev_schema&gt;_staging.stg_knoema_stock_history
 where company_symbol =&#39;AAPL&#39; 
   and stock_date =&#39;2021-03-01&#39;
</code></pre>
<p class="image-container"><img alt="staging" src="img/f346ef01c6f30959.png"></p>
<p>In this dataset, different measures like Close, Open, High and Low price are represented as different rows. For our use case, this is a bit suboptimal - it would be better to see that data transposed into columns; something more like this:</p>
<p class="image-container"><img alt="staging" src="img/3143c6412f1629af.png"></p>
<p>So let&#39;s do that!</p>


      </google-codelab-step>
    
      <google-codelab-step label="dbt pipelines - Intermediate" duration="10">
        <h2 is-upgraded>Setting up our intermediate models</h2>
<p>To achieve this, we are going to have to create a few more models:</p>
<ol type="1">
<li>Now let&#39;s create a new intermediate model in the core folder. You can do this by clicking on <code>New File</code>. Remove the prewritten path and paste in the following path: models/marts/core/intermediate/int_knoema_stock_history.sql</li>
</ol>
<p class="image-container"><img alt="intermediate" src="img/667630a4d3a17d5f.png"></p>
<p>This will create the file as well as the intermediate folder in the core folder to organize the intermediate models.</p>
<p>Intermediate tables are transformations to get to the end data product but won&#39;t be queried in the downstream processes like in the BI layer.</p>
<ol type="1" start="2">
<li>Paste this code in the model and click &#34;Save&#34;. We are going to use the dbt_utils pivot macro  to transpose the dataset from rows to columns. We have also nested in another dbt_utils macro called get_columns to help us list the column values dynamically.</li>
<li>Paste this code in the model and save. We are going to use the <a href="https://github.com/dbt-labs/dbt-utils/tree/0.7.1/#pivot-source" target="_blank">dbt_utils pivot macro</a> to transpose the dataset from rows to columns. We have also nested in another dbt_utils macro called <a href="https://github.com/dbt-labs/dbt-utils/tree/0.7.1/#get_column_values-source" target="_blank">get_columns</a> to help us list the column values dynamically.</li>
</ol>
<pre><code language="language-sql" class="language-sql">with stock_history as (

    select * from &#123;&#123; ref(&#39;stg_knoema_stock_history&#39;) }}
        where indicator_name in (&#39;Close&#39;, &#39;Open&#39;,&#39;High&#39;,&#39;Low&#39;, &#39;Volume&#39;, &#39;Change %&#39;) 

),

pivoted as (

    select 
        company_symbol, 
        company_name, 
        stock_exchange_name, 
        stock_date, 
        data_source_name,
        &#123;&#123; dbt_utils.pivot(
      column = &#39;indicator_name&#39;,
      values = dbt_utils.get_column_values(ref(&#39;stg_knoema_stock_history&#39;), &#39;indicator_name&#39;),
      then_value = &#39;stock_value&#39;
            ) }}
    
    from stock_history
    group by company_symbol, company_name, stock_exchange_name, stock_date, data_source_name

)

select * from pivoted
 
</code></pre>
<ol type="1" start="4">
<li>Now let&#39;s see what dbt_utils pivot macro compiles to by clicking on the compile button. <img alt="intermediate" src="img/e4574eed976480bb.png"></li>
<li>Now let&#39;s see what happens if you don&#39;t have the dbt_utils macro to help you write the code. Create a new file in the same intermediate folder: <code>int_knoema_stock_history_alt.sql</code></li>
<li>Paste below content into the new file and click &#34;Save&#34;. In this model, we will use Snowflake&#39;s <a href="https://docs.snowflake.com/en/sql-reference/constructs/pivot.html" target="_blank">pivot</a> function.</li>
</ol>
<pre><code language="language-sql" class="language-sql">with stock_history as (
 
    select * from &#123;&#123; ref(&#39;stg_knoema_stock_history&#39;) }}
        where indicator_name IN (&#39;Close&#39;, &#39;Open&#39;,&#39;High&#39;,&#39;Low&#39;, &#39;Volume&#39;, &#39;Change %&#39;) 
 
),
 
pivoted as (
 
    select * from stock_history 
        pivot(sum(stock_value) for indicator_name in (&#39;Close&#39;, &#39;Open&#39;,&#39;High&#39;,&#39;Low&#39;, &#39;Volume&#39;, &#39;Change %&#39;)
            ) as 
            p(
                company_symbol, 
                company_name, 
                stock_exchange_name, 
                stock_date, 
                data_source_name, 
                close,
                open,
                high,
                low,
                volume,change
            ) 
)
 
select * from pivoted

</code></pre>
<p>What did you think of the difference? While both models create the same end result, the <a href="https://github.com/dbt-labs/dbt-utils#pivot-source" target="_blank">dbt_utils.pivot macro</a> requires less code and less brainpower. All you had to do is fill in the columns and the model to obtain the same end result. It is also more dynamic, automatically updating at compilation if a new value appears.</p>
<p>You might have also noticed that in these models we are using a function called <a href="https://docs.getdbt.com/reference/dbt-jinja-functions/ref" target="_blank">ref</a>. This ref function is very similar to sources function but rather than telling dbt how a model relates to a source declared in the sources.yml file, the ref function tells dbt how a model relates to another model. It&#39;s useful in the same reasons as sources():</p>
<ul>
<li>You will be able to automatically generate a DAG and promote your code through environments without having to update the code to change the database object.</li>
<li>Refs also allow you to run based on dependencies as you will see below.</li>
</ul>
<p>The main takeaway to remember is in a dbt project, you should never have to hardcode a database object. Always uses <a href="https://docs.getdbt.com/docs/building-a-dbt-project/using-sources" target="_blank">sources()</a> and <a href="https://docs.getdbt.com/reference/dbt-jinja-functions/ref" target="_blank">refs()</a></p>
<ol type="1" start="7">
<li>Now let&#39;s go ahead and create the new models in Snowflake. In this case, rather than running based on the model file, we will run based on dependencies. Run the following command to execute the int_knoema_stock_history model and its parent models.</li>
</ol>
<p><code>dbt run --select +int_knoema_stock_history</code></p>
<p>You should see that we have run all of the nodes (excluding sources) to the left of this lineage.</p>
<p class="image-container"><img alt="intermediate" src="img/28f12c99bcc6b66f.png"></p>
<p class="image-container"><img alt="intermediate" src="img/6c2287a8096e296c.png"></p>
<ol type="1" start="8">
<li>Execute the below code, either in the Snowflake UI or in the dbt Cloud IDE</li>
</ol>
<pre><code language="language-sql" class="language-sql">SELECT * 
  FROM pc_dbt_db.&lt;dev_schema&gt;_marts.int_knoema_stock_history
 WHERE company_symbol = &#39;AAPL&#39;
   AND stock_date = &#39;2021-03-01&#39;
</code></pre>
<p>Looks like we have what we wanted!</p>
<p>Now let&#39;s take a look at our exchange rates and create some intermediate tables on top of them.</p>
<ol type="1" start="9">
<li>Create a file called <code>int_fx_rates.sql</code> in the intermediate folder (models/marts/core/intermediate/int_fx_rates.sql).</li>
</ol>
<pre><code language="language-sql" class="language-sql">&#123;&#123; 
config(
    materialized=&#39;view&#39;, 
      tags=[&#34;hourly&#34;]
    ) 
}}
 
select * from &#123;&#123; ref(&#39;stg_knoema_fx_rates&#39;) }} 
 where indicator_name = &#39;Close&#39; 
   and frequency = &#39;D&#39; 
   and exchange_date &gt; &#39;2016-01-01&#39;
</code></pre>
<p>There&#39;s now a model configuration on top of our model. dbt offers <a href="https://docs.getdbt.com/docs/building-a-dbt-project/building-models/materializations" target="_blank">various materialization options</a>. By default, if a materialization is not declared, the model will be created as a view. For this directory (marts) that the model is nested in, we have configured in our <code>dbt_project.yml</code> that the default materialization is <code>table</code>. We will override the project level materialization with our model configuration, declaring the model to be materialized as a view. We also include a <a href="https://docs.getdbt.com/reference/resource-configs/tags" target="_blank">tag</a>. Tags can be used to run parts of your project or a good way to group your models based on content and intent.</p>
<ol type="1" start="10">
<li>Let&#39;s try running this model based on a tag. In the command line, run :</li>
</ol>
<p><code>dbt run --select tag:hourly</code></p>
<p>Being able to run models based on tags can be helpful for, say, an hourly job where you are selectively running specific models.</p>
<p class="image-container"><img alt="intermediate" src="img/c30a37b6e39be54c.png"></p>
<ol type="1" start="11">
<li>Now create the file <code>int_stock_history_major_currency.sql</code> in the intermediate folder. This model will start bringing FX and Trade history sets together.</li>
<li>Paste the below code into the file and save it.</li>
</ol>
<pre><code language="language-sql" class="language-sql">with
stock_history as (
    select * from &#123;&#123; ref(&#39;int_knoema_stock_history&#39;)}}
),
 
fx_rates as (
    select * from &#123;&#123; ref(&#39;int_fx_rates&#39;) }}
),
 
fx_rates_gdp as (
    select * from fx_rates
        where currency = &#39;USD/GBP&#39;   
),
 
fx_rates_eur as (
    select * from fx_rates
        where currency = &#39;USD/EUR&#39; 
),
 
joined as (
    select 
        stock_history.*,
        fx_rates_gdp.exchange_value * stock_history.&#34;Open&#34; as gbp_open,       
        fx_rates_gdp.exchange_value * stock_history.&#34;High&#34; as gbp_high,     
        fx_rates_gdp.exchange_value * stock_history.&#34;Low&#34; as gbp_low,   
        fx_rates_gdp.exchange_value * stock_history.&#34;Close&#34; as gbp_close,     
        fx_rates_eur.exchange_value * stock_history.&#34;Open&#34; as eur_open,       
        fx_rates_eur.exchange_value * stock_history.&#34;High&#34; as eur_high,     
        fx_rates_eur.exchange_value *stock_history.&#34;Low&#34; as eur_low,
        fx_rates_eur.exchange_value * stock_history.&#34;Close&#34; as eur_close    
    from stock_history
    left join fx_rates_gdp on stock_history.stock_date = fx_rates_gdp.exchange_date
    left join fx_rates_eur on stock_history.stock_date = fx_rates_eur.exchange_date
)
 
select * from joined
</code></pre>
<ol type="1" start="13">
<li>Now, let&#39;s deploy newly built models by typing the following into the command line. <code>dbt run --select +int_stock_history_major_currency</code></li>
</ol>
<p class="image-container"><img alt="intermediate" src="img/81f61429a093680c.png"></p>
<h3 is-upgraded>Generate Documentation Site</h3>
<p>Now that we have created a few models, let&#39;s talk about <a href="https://docs.getdbt.com/docs/building-a-dbt-project/documentation" target="_blank">dbt documentation</a>. dbt is able to generate a static webpage with a data dictionary by pulling in information from your dbt project as well as your Snowflake information_schema. It also provides an interactive DAG so you can see the full lineage of your models; this is something you might have also noticed  in the lineage tab of the IDE. This is a fantastic way to share  information with your internal teams, as it contains all-important information about columns, tags, free-form model description, tests as well as the source code that is always in line with the code. So regardless of how big your project grows, it is super easy to understand what&#39;s happening with the help of dbt&#39;s documentation.</p>
<ol type="1">
<li>To generate your documentation site, execute &#34;dbt docs generate&#34; on the command line:</li>
</ol>
<p><code>dbt docs generate</code></p>
<ol type="1" start="14">
<li>Click on <code>View Docs</code> on the top left side.</li>
</ol>
<p class="image-container"><img alt="intermediate" src="img/37a73285bf78cfdd.png"></p>
<ol type="1" start="15">
<li>Take a look around on the docs site. You can check out the project lineage by clicking on the DAG button on the bottom. Explore the page and think about what information you would want to provide to your stakeholders and teammates.</li>
</ol>
<p class="image-container"><img alt="intermediate" src="img/24d69956d417688.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="dbt pipelines - Seeds" duration="5">
        <p>Following our use case story, we are going to manually upload two small datasets using <a href="https://docs.getdbt.com/docs/building-a-dbt-project/seeds" target="_blank">dbt seed</a> representing trading books of two desks. As you might notice, they were buying and selling AAPL shares, but logging the cash paid/received in different currencies: USD and GBP.</p>
<ol type="1">
<li>Create a new file in the data folder called <code>manual_book1.csv</code>.</li>
</ol>
<p class="image-container"><img alt="seed" src="img/e08b86641b1091b8.png"></p>
<ol type="1" start="2">
<li>Paste the following code in the file and save it.</li>
</ol>
<pre><code>Book,Date,Trader,Instrument,Action,Cost,Currency,Volume,Cost_Per_Share,Stock_exchange_name
B2020SW1,2021-03-03,Jeff A.,AAPL,BUY,-17420,GBP,200,87.1,NASDAQ
B2020SW1,2021-03-03,Jeff A.,AAPL,BUY,-320050,GBP,3700,86.5,NASDAQ
B2020SW1,2021-01-26,Jeff A.,AAPL,SELL,52500,GBP,-500,105,NASDAQ
B2020SW1,2021-01-22,Jeff A.,AAPL,BUY,-100940,GBP,980,103,NASDAQ
B2020SW1,2021-01-22,Nick Z.,AAPL,SELL,5150,GBP,-50,103,NASDAQ
B2020SW1,2019-08-31,Nick Z.,AAPL,BUY,-9800,GBP,100,98,NASDAQ
B2020SW1,2019-08-31,Nick Z.,AAPL,BUY,-1000,GBP,50,103,NASDAQ
</code></pre>
<ol type="1" start="3">
<li>Create another file <code>manual_book2.csv</code> in the data folder.</li>
<li>Paste the following code in the file and save it.</li>
</ol>
<pre><code>Book,Date,Trader,Instrument,Action,Cost,Currency,Volume,Cost_Per_Share,Stock_exchange_name
B-EM1,2021-03-03,Tina M.,AAPL,BUY,-17420,EUR,200,87.1,NASDAQ
B-EM1,2021-03-03,Tina M.,AAPL,BUY,-320050,EUR,3700,86.5,NASDAQ
B-EM1,2021-01-22,Tina M.,AAPL,BUY,-100940,EUR,980,103,NASDAQ
B-EM1,2021-01-22,Tina M.,AAPL,BUY,-100940,EUR,980,103,NASDAQ
B-EM1,2019-08-31,Tina M.,AAPL,BUY,-9800,EUR,100,98,NASDAQ
</code></pre>
<ol type="1" start="5">
<li>Now let&#39;s run the <code>dbt seed</code> command to load the data into Snowflake. It is important to mention that while it is absolutely possible with this approach to bring low hundred-thousands of rows, it was not created for larger datasets and you should be using COPY/Snowpipe or other data integration options recommended for Snowflake in such cases.</li>
</ol>
<p><code>dbt seed</code></p>
<p>You can see that it loaded the files in the default schema because we didn&#39;t declare a schema for them. If we wanted to make sure the files were loaded into a specific file, we could go back to the dbt_project.yml and add that <a href="https://docs.getdbt.com/reference/seed-configs" target="_blank">schema configuration</a>.</p>
<p class="image-container"><img alt="seed" src="img/e879f05a653208e9.png"></p>
<ol type="1" start="6">
<li>Commit your work.</li>
<li>Now let&#39;s model the seeded data by unioning them together. In this example we are going to see how <a href="https://github.com/dbt-labs/dbt-utils#union_relations-source" target="_blank">dbt_utils.union_relations</a> macro helps us write the necessary code. Create the file <code>int_unioned_book.sql</code> in the intermediate folder.</li>
<li>Paste the code below into the new file and save it.</li>
</ol>
<pre><code language="language-sql" class="language-sql">with 
unioned as (
    &#123;&#123; dbt_utils.union_relations(
        relations=[ref(&#39;manual_book1&#39;), ref(&#39;manual_book2&#39;)]
    ) }}
 
),
 
renamed as (
    select      
        Book,
        Date as book_date,
        Trader,
        Instrument,
        Action as book_action,
        Cost,
        Currency,
        Volume,
        Cost_Per_Share,
        Stock_exchange_name
    from unioned 
)
 
select * from renamed
</code></pre>
<ol type="1" start="9">
<li>Before we deploy this model, let&#39;s have a look at what it is compiled into. You can do this by clicking on the compile button.</li>
</ol>
<p class="image-container"><img alt="seed" src="img/ca8db96dbbf8180d.png"></p>
<p>As you can see,  the macro from the dbt_utils package wrote the code, aligned the attributes by name and type, and combined the datasets via a UNION ALL. The beauty of this is, we were able to write 46 lines of code with only 3.  It&#39;s also dynamic so if we were to add new columns to our referenced models, dbt would update the compile code with the new fields. You can imagine the amount of time saved.</p>
<ol type="1" start="10">
<li>Now let&#39;s create the object by running:</li>
</ol>
<p><code>dbt run --select int_unioned_book</code></p>


      </google-codelab-step>
    
      <google-codelab-step label="dbt pipelines - Intermediate Part 2" duration="5">
        <ol type="1">
<li>Next challenge! We have a great log of trading activities, but it only provides records when shares were bought or sold. Ideally, to make the daily performance analysis more meaningful, we should have rows for the days shares were held as well. To do this, let&#39;s make this new file: <code>int_daily_position.sql</code> in the intermediate folder.</li>
<li>Paste below into the new file and save it.</li>
</ol>
<pre><code language="language-sql" class="language-sql">with 
stock_history as (
    select * from &#123;&#123; ref(&#39;int_stock_history_major_currency&#39;) }} 
), 

unioned_book as (
    select * from &#123;&#123; ref(&#39;int_unioned_book&#39;) }}
),

cst_market_days as (
    select distinct stock_date
        from stock_history
        where stock_history.stock_date &gt;= (select min(book_date) as min_dt from  unioned_book)
),

joined as (
    select 
        cst_market_days.stock_date,
        unioned_book.trader,
        unioned_book.stock_exchange_name,
        unioned_book.instrument,
        unioned_book.book,
        unioned_book.currency,
        sum(unioned_book.volume) as total_shares
    from cst_market_days
    inner join unioned_book on unioned_book.book_date = cst_market_days.stock_date
    where unioned_book.book_date &lt;= cst_market_days.stock_date
    &#123;&#123; dbt_utils.group_by(6) }}
)

select * from joined

</code></pre>
<p>You might have noticed we used another dbt_utils macro. Rather than having to manually list out all of the columns to group by, you can use the <a href="https://github.com/dbt-labs/dbt-utils#group_by-source" target="_blank">dbt_utils group_by macro</a> to write it for you.</p>
<ol type="1" start="3">
<li>Now let&#39;s group the daily position with trades. Create the file <code>int_daily_position_with_trades.sql</code> in the intermediate folder.</li>
<li>Paste the following code in the new file and save it.</li>
</ol>
<pre><code language="language-sql" class="language-sql">with unioned_book as (
    select * from &#123;&#123; ref(&#39;int_unioned_book&#39;) }}
),
 
daily_position as (
    select * from &#123;&#123; ref(&#39;int_daily_position&#39;) }}
),
 
unioned as (
    select 
        book,
        book_date,
        trader,
        instrument,
        book_action,
        cost, 
        currency,
        volume, 
        cost_per_share, 
        stock_exchange_name,
        sum(unioned_book.volume) 
            over(
                partition by 
                    instrument, 
                    stock_exchange_name, 
                    trader 
                order by 
                    unioned_book.book_date rows unbounded preceding) 
                        as total_shares
    from unioned_book  
 
    union all 
 
    select  
        book,
        stock_date as book_date, 
        trader, 
        instrument, 
        &#39;HOLD&#39; as book_action,
        0 as cost,
        currency, 
        0 as volume, 
        0 as cost_per_share,
        stock_exchange_name,
        total_shares
    from daily_position
    where (book_date,trader,instrument,book,stock_exchange_name) 
        not in 
        (select book_date,trader,instrument,book,stock_exchange_name
            from unioned_book
        )
)
 
select * from unioned

</code></pre>
<ol type="1" start="5">
<li>Execute the following code to build int_unioned_book and it&#39;s child models.</li>
</ol>
<p><code>dbt run --select int_unioned_book+</code></p>
<p>Now that we have created all of these models, we are able to attribute shares by trader.</p>
<p class="image-container"><img alt="int" src="img/b51ea6f8acadaca3.png"></p>
<ol type="1" start="6">
<li>Commit the work.</li>
<li>Run the following code in either the dbt Cloud IDE or a Snowflake worksheet.</li>
</ol>
<pre><code language="language-sql" class="language-sql">select * 
from pc_dbt_db.&lt;dev_schema&gt;_marts.int_daily_position_with_trades
where trader = &#39;Tina M.&#39;
order by  book_date
</code></pre>
<p class="image-container"><img alt="int" src="img/c14bd0208f5cbc2a.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="dbt pipelines - Facts" duration="5">
        <h3 is-upgraded>dbt pipelines - PnL calculation</h3>
<p>Now for the last models in our tale. We have the trading history of our desks and our stock price history.</p>
<p>Let&#39;s create a model to show how Market Value and PnL changed over time. You might notice that this is going into our core folder. This is because this is a part of the core logic of our fictional company. This model will be a source of truth, to be used by many in downstream processes like a BI tool.</p>
<ol type="1">
<li>Create the file <code>fct_trading_pnl.sql</code> in the core folder.</li>
<li>Copy the following code to the new file and save it.</li>
</ol>
<pre><code language="language-sql" class="language-sql">&#123;&#123; 
config(
      tags = &#39;core&#39;
      ) 
}}


with
daily_positions as (
    select * from &#123;&#123; ref(&#39;int_daily_position_with_trades&#39; )}}

),

stock_history as (
    select * from &#123;&#123; ref(&#39;int_stock_history_major_currency&#39;) }}

),

joined as (
    select 
        daily_positions.instrument, 
        daily_positions.stock_exchange_name, 
        daily_positions.book_date, 
        daily_positions.trader, 
        daily_positions.volume,
        daily_positions.cost, 
        daily_positions.cost_per_share,
        daily_positions.currency,
        sum(cost) over(
                partition by 
                    daily_positions.instrument, 
                    daily_positions.stock_exchange_name, 
                    trader 
                order by
                    daily_positions.book_date rows unbounded preceding 
                    )
                as cash_cumulative,
       case when daily_positions.currency = &#39;GBP&#39; then gbp_close
            when daily_positions.currency = &#39;EUR&#39; then eur_close
            else &#39;Close&#39;
       end AS close_price_matching_ccy, 
       daily_positions.total_shares  * close_price_matching_ccy as market_value, 
       daily_positions.total_shares  * close_price_matching_ccy + cash_cumulative as PnL
   from daily_positions
   inner join stock_history 
      on daily_positions.instrument = stock_history.company_symbol 
     and stock_history.stock_date = daily_positions.book_date 
     and daily_positions.stock_exchange_name = stock_history.stock_exchange_name
)

select * from joined 
</code></pre>
<ol type="1" start="3">
<li>Run the model with <code>dbt run --select fct_trading_pnl.sql</code></li>
</ol>
<p>You might have noticed that fct_trading_pnl takes some time to build when you do a dbt run. As we use larger and larger datasets, the run times are getting longer. We have already materialized our models as a table, meaning we are preemptively front loading our run times to save on the query times when the table is queried. We could always increase our warehouse size, but there&#39;s another trick up our sleeve we won&#39;t touch on just yet.</p>
<p>We can materialize the model as an incremental model, meaning that it will not be rebuilt each time, but rather only the latest rows transformed and added to the existing table. All you have to do is update the model configuration and include the is_incremental macro which comes into action for the incremental runs (and is ignored during initial run and <a href="https://docs.getdbt.com/reference/resource-configs/full_refresh" target="_blank">full_refresh</a> option). You can learn more about this <a href="http://greatexpectations.io/" target="_blank">incremental materialization here</a>.</p>
<ol type="1" start="4">
<li>Let&#39;s try out an incremental model. Create a new file <code>fct_trading_pnl_incremental.sql</code> in the core folder.</li>
<li>Copy the following code to the new file and save it.</li>
</ol>
<pre><code language="language-sql" class="language-sql">&#123;&#123; 
config(
      materialized=&#39;incremental&#39;,
      unique_key= &#39;pk_key&#39;,
      tags = &#39;core&#39;
      ) 
}}
 
 
with 
daily_positions as (
    select * from &#123;&#123; ref(&#39;int_daily_position_with_trades&#39; )}}
),
 
stock_history as (
    select * from &#123;&#123; ref(&#39;int_stock_history_major_currency&#39;) }}
),
 
joined as (
    select 
 
        daily_positions.instrument, 
        daily_positions.stock_exchange_name, 
        daily_positions.book_date, 
        daily_positions.trader, 
        daily_positions.volume,
        daily_positions.cost, 
        daily_positions.cost_per_share,
        daily_positions.currency,
        sum(cost) over(
                partition by 
                    daily_positions.instrument, 
                    daily_positions.stock_exchange_name, 
                    trader 
                order by
                    daily_positions.book_date rows unbounded preceding 
                    )
                as cash_cumulative,
       case when daily_positions.currency = &#39;GBP&#39; then gbp_close
            when daily_positions.currency = &#39;EUR&#39; then eur_close
            else &#39;Close&#39;
       end as close_price_matching_ccy, 
       daily_positions.total_shares  * close_price_matching_ccy as market_value, 
       daily_positions.total_shares  * close_price_matching_ccy + cash_cumulative as PnL
   from daily_positions
   inner join stock_history 
      on daily_positions.instrument = stock_history.company_symbol 
     and stock_history.stock_date = daily_positions.book_date 
     and daily_positions.stock_exchange_name = stock_history.stock_exchange_name
),
 
primary_key as (
 
    select 
 
        &#123;&#123; dbt_utils.surrogate_key([
                &#39;trader&#39;, 
                &#39;instrument&#39;, 
                &#39;book_date&#39;, 
                &#39;stock_exchange_name&#39;,
                &#39;PnL&#39;, 
            ]) }} as pk_key,
                *
 
    from joined 
)
 
select * from primary_key
 
{% if is_incremental() %}
  -- this filter will only be applied on an incremental run
   where book_date &gt; (select max(book_date) from &#123;&#123; this }})
 
{% endif %}

</code></pre>
<ol type="1" start="6">
<li>Now let&#39;s see how differently this model acts in the first run versus subsequent runs. Run <code>dbt run --select fct_trading_pnl_incremental</code> twice and compare the logs.</li>
</ol>
<p>For the first run, you will notice that the where clause does not come in into the sql statement.</p>
<p>In subsequent runs, dbt is including the where clause to create a temporary table to then merge into the existing table. The first run of an incremental model will builds the table that will then new rows will be added to in subsequent runs.</p>
<p>First run: <img alt="fct" src="img/3480736437445929.png"></p>
<p>Second run: <img alt="fct" src="img/7ae799d2cef23af.png"></p>
<p>You will not see a true performance improvement in this example because our data is not loading exponentially but in production applications, you will.</p>


      </google-codelab-step>
    
      <google-codelab-step label="dbt pipelines - Tests &amp; Docs" duration="5">
        <h2 is-upgraded>Testing &amp; Documentation</h2>
<p>To build trust in data with your organization, it is impossible to overstate the importance of testing and documentation. While there are many ways to organize automated testing and documentation, dbt comes with an accessible <a href="https://docs.getdbt.com/docs/building-a-dbt-project/tests" target="_blank">data testing</a> and <a href="https://docs.getdbt.com/docs/building-a-dbt-project/documentation" target="_blank">documentation</a> framework.</p>
<p>For tests, dbt comes with a set of 4 pre-defined data tests:</p>
<ul>
<li>uniqueness</li>
<li>not_null</li>
<li>check constraints</li>
<li>relationship integrity</li>
</ul>
<p>We are going to set up tests on a few models for this workshop. However, we strongly recommend you establish reasonable test coverage across the board. Adding your own tests is easy; as long as it can be written as a select statement, you can use it as a test. And just like with macros, there are plenty of fantastic packages out there like the <a href="https://hub.getdbt.com/calogica/dbt_expectations/latest/" target="_blank">dbt_expectations</a> package that provides tests similar to the <a href="http://greatexpectations.io/" target="_blank">Great Expectations</a> open source project.</p>
<p>For documentation, dbt takes model and column descriptions and will add them to the documentation site so that you have even more information about your models to share with your stakeholders via the site. It also pulls in information from the Snowflake information schema for a one stop show about your data project.</p>
<p>Now let&#39;s add testing and documentation to this project.</p>
<ol type="1">
<li>First, create this file <code>intermediate.yml</code> in the intermediate folder.</li>
<li>Copy the following code into the new file and save it.</li>
</ol>
<pre><code language="language-yml" class="language-yml">version: 2
 
models:
  - name: int_fx_rates
    description: &#34;An intermediate model that filters stg_knoema_fx_rates&#34;
    columns:
      - name: currency||exchange_date
        tests:
          - unique
          - not_null
 
  - name: int_unioned_book
    description: &#34;An intermediate model unions the manual_book csvs&#34;
    columns:
      - name: instrument
        tests:
          - not_null
          - relationships:
              to: ref(&#39;int_knoema_stock_history&#39;)
              field: company_symbol
 
  - name: int_knoema_stock_history
    description: &#34;An intermediate model that pivots the stg_knoema_stock_history model by indicator&#34;
    columns:
      - name: company_symbol||stock_date
        tests:
          - not_null
          - unique
</code></pre>
<p class="image-container"><img alt="test" src="img/f27ba6b8a4fdbd0d.png"></p>
<ol type="1" start="3">
<li>Execute the following code on the command line:<br><code>dbt test</code></li>
</ol>
<p class="image-container"><img alt="test" src="img/e5f8bb595a6a8595.png"></p>
<p>Oh no! One of our tests failed! Let&#39;s try to understand why. If you click into the details tab, dbt provides you with the SQL query that failed.</p>
<p class="image-container"><img alt="test" src="img/db2c185c6431c004.png"></p>
<p>Now let&#39;s take that query and paste it either into the Snowflake UI or the IDE to debug it.</p>
<ol type="1" start="4">
<li>Execute the following query to check the full row width for one of the records failed either in the IDE or the Snowflake UI (remember to update the dev_schema!):</li>
</ol>
<pre><code language="language-sql" class="language-sql">with cst as
(
    select
        company_symbol||stock_date as conctat
    from &lt;dev_schema&gt;_marts.int_knoema_stock_history
    where company_symbol||stock_date is not null
    group by company_symbol||stock_date
    having count(*) &gt; 1 
    limit 1
)
 
select * from &lt;dev_schema&gt;_marts.int_knoema_stock_history
where company_symbol||stock_date IN (SELECT conctat FROM cst)

</code></pre>
<p class="image-container"><img alt="test" src="img/fc02147de5b1df24.png"></p>
<p>Aha! There are shares which are traded on more than one stock exchanges. So we need to include the stock_exchange_name attribute to the unique test key.</p>
<ol type="1" start="4">
<li>Let&#39;s go back to <code>intemediate.yml</code> file and update the test configuration for int_knoema_stock_history model :</li>
</ol>
<pre><code language="language-yml" class="language-yml">version: 2

models:
  - name: int_fx_rates
    description: &#34;An intermediate model that filters stg_knoema_fx_rates&#34;
    columns:
      - name: currency||exchange_date
        tests:
          - unique
          - not_null

  - name: int_unioned_book
    description: &#34;An intermediate model unions the manual_book csvs&#34;
    columns:
      - name: instrument
        tests:
          - not_null
          - relationships:
              to: ref(&#39;int_stock_history&#39;)
              field: company_symbol

  - name: int_knoema_stock_history
    description: &#34;An intermediate model that pivots the stg_knoema_stock_history model by indicator&#34;
    columns:
      - name: company_symbol||stock_date||stock_exchange_name
        tests:
          - not_null
          - unique
</code></pre>
<ol type="1" start="5">
<li>Now let&#39;s run only the previously failing test.</li>
</ol>
<p><code>dbt test -m  int_knoema_stock_history</code></p>
<p class="image-container"><img alt="test" src="img/33c79e94001d83a1.png"></p>
<p>Look at all that green! Now the last thing to do is to generate the documentation and see how our description fields are populated.</p>
<ol type="1" start="6">
<li>Run the command <code>dbt docs generate</code> and click on view docs.</li>
<li>Search for one of the models that we applied descriptions to either via the file tree or the search bar.</li>
</ol>
<p class="image-container"><img alt="docs" src="img/bb440fe58c5b9d0.png"></p>
<p>You should now see the description field populated.</p>
<p class="image-container"><img alt="docs" src="img/ee27e4e7de8a480e.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="dbt pipelines - Deployment" duration="5">
        <p>Okay, it seems like we have everything in place: pipelines have been developed, tested and documented.</p>
<p>The next step would be to promote this code up the chain through our environments (which in this lab are simplified to just DEV &amp; PROD). We&#39;ll do this by committing the work to our feature branch into the main branch and setting up a job to orchestrate the execution of the models in production. Generally it would be best for a pull request to be opened, so that your code is reviewed and tested via <a href="https://docs.getdbt.com/docs/dbt-cloud/using-dbt-cloud/cloud-enabling-continuous-integration-with-github#slim-ci" target="_blank">Slim CI</a> prior to promotion to production, but in the interest of keeping things concise for this workshop, we are going to merge into production without review.</p>
<ol type="1">
<li>To do this, the first thing you are going to do is commit any remaining work you haven&#39;t yet.</li>
</ol>
<p class="image-container"><img alt="deploy" src="img/b515cea07cf1e6f3.png"></p>
<ol type="1" start="2">
<li>Now we are going to click merge to master <img alt="deploy" src="img/f973e7c0643a2df9.png"></li>
</ol>
<p>By merging into master, you should have reverted back to your master branch for you to start the cycle over again for development.</p>
<p class="image-container"><img alt="deploy" src="img/35aa09a5c16be611.png"></p>
<ol type="1" start="3">
<li>Now we are going to deploy our code via dbt Cloud. Luckily for you, Partner Connection has already created your Production Environment for you. Now all we have to do is update some defaults.</li>
</ol>
<p>Click on the hamburger menu and click on <code>Environments</code>.</p>
<p class="image-container"><img alt="deploy" src="img/495518f3e6f114f7.png"><img alt="deploy" src="img/43c557a087a4003d.png"></p>
<p>You should see two different Environments: Development and Deployment.</p>
<ol type="1" start="4">
<li>Click on the <code>Deployment</code> environment and then click on <code>Settings</code> in the top right.</li>
</ol>
<p class="image-container"><img alt="deploy" src="img/e8e0d24095155dc2.png"><img alt="deploy" src="img/eb05b651820003e6.png"></p>
<ol type="1" start="5">
<li>We are going to update the schema name from your development schema to <code>production</code>. To do this, click on Edit.</li>
</ol>
<p class="image-container"><img alt="deploy" src="img/dd9e08389e820b0a.png"></p>
<ol type="1" start="6">
<li>After you update the field, be sure to click on <code>Save</code> at the top. Now in doing this, dbt will default to building in a schema named <code>production</code> in the declared default database pc_dbt_db. This helps us separate out the objects we create in our production environment from our development sandbox.</li>
<li>After saving your environment, let&#39;s update the default Partner Connect created job. To do this, click on the hamburger menu on the top left and click on <code>Jobs</code>.</li>
</ol>
<p class="image-container"><img alt="deploy" src="img/b8fcd73d8a19d345.png"></p>
<ol type="1" start="8">
<li>Now select the pre-configured job named <code>Partner Connect Trial Job</code>.</li>
<li>Now let&#39;s edit it by first going to <code>Settings</code>.</li>
<li>Click on <code>Edit</code> on the top right.</li>
<li>And now we are going to update a few things. Change the name of the Job to <code>Production Job</code> to signify that this is going to be your production run. Update the number of <a href="https://docs.getdbt.com/dbt-cli/configure-your-profile#understanding-threads" target="_blank">threads</a> to 8. This will allow dbt to run 8 dbt models in the DAG concurrently sans dependencies. 8 is the default we recommend for Snowflake.</li>
</ol>
<p class="image-container"><img alt="deploy" src="img/cc101238b715a131.png"></p>
<ol type="1" start="12">
<li>Because the dbt commands section already include the sequence of commands that we need things to operate, we are going to keep it as is. We want to seed our manual uploads to our production schema first. Then we want to create our objects in our schema prior to running tests on them. We are also going to leave the scheduling on it&#39;s default off configuration because we will be manually kicking off the job for this workshop.</li>
<li>Now go to the top and click <code>Save</code>.</li>
<li>Then click on the job name in the path on top. This will return you to the job run history page, from where you can click on <code>Run now</code>.</li>
<li>Click into the run to check out how the run is going. Your run should be successful like this after completion. <img alt="deploy" src="img/459b6b1e696173fb.png"></li>
<li>Take a look at the various run steps. You can validate that on the dbt run step, you are building into the prod schemas as noted in our environment configuration.</li>
<li>Verify  in Snowflake UI that you now we have data in the production schema:</li>
</ol>
<p class="image-container"><img alt="deploy" src="img/8b8b30073fbacf6d.png"></p>
<p>And this concludes our workshop! If you&#39;re interested in exploring further, there are &#34;extra credit&#34; tasks in the appendix of this workshop, in which you&#39;ll cover things like how to visualize what you&#39;ve created with Snowsight.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Conclusion &amp; Next Steps" duration="1">
        <p>Congratulations on completing the lab!</p>
<p>Today, you learned how to use dbt and Snowflake to build data transformation pipelines for analytics. You&#39;re now ready to apply these fundamentals to your own data. We encourage you to continue with your free trial by loading your own sample or production data, and by continuing to dive into some of the more advanced functionality of dbt Cloud and Snowflake.</p>
<h3 is-upgraded>What we&#39;ve covered:</h3>
<ul>
<li>How to set up dbt &amp; Snowflake</li>
<li>How to leverage data in Snowflake&#39;s Data Marketplace</li>
<li>How to run a dbt project and develop pipelines</li>
<li>How to create data tests and documentation</li>
</ul>
<h3 is-upgraded>Additional Resources:</h3>
<ul>
<li>Join our <a href="https://community.getdbt.com/" target="_blank">dbt community Slack </a> which contains more than 18,000 data practitioners today. We have a dedicated slack channel #db-snowflake to Snowflake related content.</li>
<li>To continue to learn to use dbt more effectively, check out the <a href="https://learn.getdbt.com/" target="_blank">dbt Learn site</a>.</li>
<li>Contact the <a href="https://www.getdbt.com/contact/" target="_blank">dbt Cloud Sales team</a> if you&#39;re interested in exploring dbt Cloud for your team or organization.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Appendix" duration="0">
        <h2 is-upgraded>Visualizations</h2>
<ol type="1">
<li>If you want to create a simple data visualization for this dataset, we can use Snowsight. To do that, let&#39;s click on the Preview App button once again:</li>
<li>Enable the Dashboards and worksheets.</li>
<li>Then click Worksheets -&gt; + Worksheet to add a new one.</li>
<li>Copy and paste the following query in the worksheet.</li>
</ol>
<pre><code language="language-sql" class="language-sql">select * 
from pc_dbt_db.&lt;dev_schema&gt;_marts.int_daily_position_with_trades
where trader = &#39;Tina M.&#39;
order by  book_date
</code></pre>
<ol type="1" start="5">
<li>Hit the run button and switch from a table view to chart.</li>
<li>By default it shows a breakdown by Volume. Click on the measure and switch it into PNL.</li>
<li>Click &#34;+Add column&#34; to add another measure and select &#34;Market Value&#34; to display Market value and PnL side by side.</li>
</ol>
<p>And that&#39;s it! Now you have a worksheet that you can slice and dice, share with your colleagues or embed in the SnowSight dashboard as a tile. For more details on SnowSight, please refer to the Snowflake documentation.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/native-shim.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/custom-elements.min.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/prettify.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>
  <script type="text/javascript">
    window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var r=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(r?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["addEventProperties","addUserProperties","clearEventProperties","identify","removeEventProperty","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
    heap.load("2025084205");
  </script>
</body>
</html>
