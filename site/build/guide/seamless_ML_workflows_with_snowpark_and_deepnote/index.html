
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Seamless Machine Learning Workflows with Snowpark &amp; Deepnote</title>

  
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5Q8R2G');</script>
  

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-08H27EW14N"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-08H27EW14N');
</script>

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q8R2G"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  
  <google-codelab-analytics gaid="UA-41491190-9"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="seamless_ML_workflows_with_snowpark_and_deepnote"
                  title="Seamless Machine Learning Workflows with Snowpark &amp; Deepnote"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Overview" duration="4">
        <h2 is-upgraded>What is Snowpark?</h2>
<p>Machine learning workflows generally involve model prototyping, evaluation, and deployment. These typically require different languages, technologies, compute environments, and interfaces. <strong>Snowpark for Python</strong> brings these disparate components together under a single Python library—greatly simplifying end-to-end machine learning workflows.</p>
<p>Snowpark provides a Python interface for interacting with data in the warehouse—without moving it to the client (i.e., the notebook). In addition, Snowpark allows data scientists to execute locally developed Python code directly in the warehouse. This means that model training (and returning predictions) can be executed from a notebook but run on the server (i.e., the warehouse)—without changing the user&#39;s code.</p>
<h2 is-upgraded>What is Deepnote?</h2>
<p>A major aspect of any ML workflow is <strong>exploratory data analysis (EDA)</strong>. During model development, data scientists need rapid insights for the purposes of feature selection, feature engineering, and hyperparameter tuning. Deepnote&#39;s collaborative data notebook is an interoperable Python and SQL environment that includes a suite of no-code tools to help with EDA. To learn more about how Deepnote helps with EDA and its tight integration with Snowflake, see <a href="https://quickstarts.snowflake.com/guide/exploratory_data_analysis_with_snowflake_and_deepnote/#0" target="_blank">this</a> quickstart.</p>
<h2 is-upgraded>Using Snowpark &amp; Deepnote together</h2>
<p>Deepnote and Snowpark solve the common pain points that data scientists experience when developing and deploying machine learning models. As shown in the image below, Snowpark and Deepnote work well together to accomplish transformation, EDA, and machine learning tasks.</p>
<p>In this quick-start guide, we will build a complete ML workflow with Deepnote and Snowpark. Specifically, we will (1) prototype a churn prediction model using Deepnote&#39;s EDA solutions and (2) use Snowpark to evaluate and deploy the model inside Snowflake&#39;s DWH.</p>
<p class="image-container"><img alt="img" src="img/28cb61e6fcf3fdaa.png"></p>
<h2 is-upgraded>Prerequisites</h2>
<ul>
<li>Familiarity with basic Python and SQL</li>
<li>Familiarity with data science notebooks (see <a href="https://quickstarts.snowflake.com/guide/exploratory_data_analysis_with_snowflake_and_deepnote/#0" target="_blank">this guide</a> for an introduction to Deepnote)</li>
</ul>
<h2 class="checklist" is-upgraded>What You&#39;ll Learn</h2>
<p>Join us in this guide where we develop a churn prediction model using Scikit-learn. We will learn the following:</p>
<ul>
<li>How to build a generalizable ML workflow that covers model prototyping, model evaluation, and deployment.</li>
<li>How to use Snowpark&#39;s DataFrame API to examine data from your Snowflake warehouse without moving it to the notebook.</li>
<li>How to train and deploy a classification model directly in the warehouse.</li>
</ul>
<h2 is-upgraded>What You&#39;ll Need</h2>
<ul>
<li>A free <a href="https://deepnote.com/sign-up?utm_source=ML_workflows_with_snowpark_&_deepnote&utm_medium=snowpark_quickstart" target="_blank">Deepnote account</a>.</li>
<li>A <a href="https://signup.snowflake.com/?utm_cta=quickstarts_" target="_blank">Snowflake account</a> with admin access and <a href="https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-packages.html" target="_blank">3rd party packages enabled</a>.</li>
<li>The telecommunications parquet data file <a href="https://drive.google.com/file/d/1ZIBz1hibyEv8DNBJj12vk52XRmCuK3q0/view?usp=share_link" target="_blank">here</a>.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Setup a Snowflake integration inside Deepnote" duration="2">
        <p>To connect a Snowflake database to a Deepnote project, open the Snowflake integration modal and supply the associated Snowflake credentials (i.e., account, username, password). Note that the connection parameters to Snowflake are stored in the notebook as Python environment variables but can only be viewed by the workspace Admin.</p>
<p class="image-container"><img alt="img" src="img/40a1dc8fedfd4309.gif"></p>
<p>Note that once you are connected to Snowflake, you will be able to browse your schema directly from Deepnote and query your tables with <a href="https://deepnote.com/docs/sql-cells" target="_blank">SQL blocks</a>. For more detailed information on using Deepnote and Snowflake together, please see <a href="https://quickstarts.snowflake.com/guide/exploratory_data_analysis_with_snowflake_and_deepnote/#0" target="_blank">this quickstart</a>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Initialize the Snowpark session" duration="2">
        <p>After connecting your Snowflake integration, click the &#34;How to use&#34; button on the newly created integration in the right sidebar. As you can see in the image below, you can insert a snippet of code into the notebook to help you get started with Snowpark. This is simply boilerplate code that will help you to initialize your Snowpark session.</p>
<p class="image-container"><img alt="img" src="img/4c95ec02b8ae75e5.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Using Snowpark&#39;s DataFrame API" duration="3">
        <p>Similar to Pandas and PySpark, Snowpark&#39;s main abstraction is the DataFrame. The SQL commands and functions that you require for selecting, joining, and aggregating tables are methods on the DataFrame object. And since this can all be done in pure Python, this opens up new possibilities for interacting with your tables (e.g., using Python control structures). In addition, data scientists that prefer Python over SQL can still can have full control over the DWH.</p>
<p>For example, the following code snippet uses a standard Python <em>for loop</em> to remove spaces from the column names directly on a view. Snowpark&#39;s session and DataFrame methods provide convenient access and manipulation of the data in the warehouse—including writing back to new tables as shown below.</p>
<pre><code language="language-python" class="language-python"># create a temporary view on raw data to use for transformation
session.table(&#34;RAW_DATA&#34;).create_or_replace_temp_view(&#39;RAW_STAGE&#39;)
df_raw_stage = session.table(&#34;RAW_STAGE&#34;)

# loop through columns and rename them
for c in df_raw_stage.columns:
    df_raw_stage=df_raw_stage.rename(c, c.replace(&#39; &#39;, &#39;&#39;))

# write the new table to the warehouse
df_raw_stage.write.mode(&#39;overwrite&#39;).saveAsTable(&#39;RAW_STAGE&#39;)
</code></pre>
<p>To further highlight how the DataFrame object abstracts away common SQL tasks, here is an example of a two-way <code>GROUPBY</code> followed by an aggregation and sorting. The resulting <code>churn_exploration</code> object can be converted into an in-memory Pandas DataFrame with the <code>.to_pandas()</code> method.</p>
<pre><code language="language-python" class="language-python">churn_exploration = (
    dfJoin.group_by([&#34;CONTRACT&#34;, &#34;CHURNVALUE&#34;])
    .count()
    .sort([&#34;CONTRACT&#34;, &#34;CHURNVALUE&#34;])
)
</code></pre>
<p>It is important to note that Snowpark operations are executed lazily on the server, which reduces the amount of data transferred between your notebook and the Snowflake database.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Prototyping machine learning models" duration="4">
        <p>After EDA, we enter a prototyping phase. Typically, this involves feature selection and generation, as well as training and evaluation of a model before productionizing it. One generalizable approach that is possible with Snowpark is to prototype your ML models in the notebook (perhaps on a sample of data), then, move that same code to the warehouse and run it on the full dataset.</p>
<p>In the snippet below, we have a function that trains a churn detection model as well as evaluates both the train and test sets. Interestingly, the function can be run using the notebook&#39;s compute (in the client); however, it can also be registered to run in the warehouse by using Snowflake&#39;s <a href="https://docs.snowflake.com/en/sql-reference/stored-procedures-python.html" target="_blank">stored procedures</a>.</p>
<pre><code language="language-python" class="language-python">def train_churn_prediction_model(session: Session, features_table: str) -&gt; Variant:

    from sklearn.model_selection import GridSearchCV
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import confusion_matrix, classification_report
    from sklearn.ensemble import RandomForestClassifier
    from sklearn.compose import make_column_transformer
    from sklearn.preprocessing import OneHotEncoder
    from sklearn.preprocessing import MinMaxScaler
    from sklearn.pipeline import make_pipeline
    from sklearn.metrics import balanced_accuracy_score

    import os
    from joblib import dump

    # Load features
    df = session.table(features_table).to_pandas()

    # gather all categorial columns for preprocessing
    cat_vars=df.select_dtypes(include=[&#39;bool&#39;, &#39;object&#39;]).columns.to_list()
    cat_vars.remove(&#39;CUSTOMERID&#39;)

    # gather all numerical columns in case we want them for preprocessing
    num_vars = df.select_dtypes(exclude=[&#39;bool&#39;, &#39;object&#39;]).columns.to_list()
    num_vars.remove(&#39;CHURNVALUE&#39;);

    # all desired columns (removing ID and target column)
    x_cols=cat_vars+num_vars

    # split the data into train and test
    X_train, X_test, y_train, y_test = train_test_split(
        df[x_cols],
        df[&#39;CHURNVALUE&#39;],
        test_size=0.2
    )

    # preprocessing columns
    col_trans = make_column_transformer(
        (OneHotEncoder(), cat_vars),
        #(MinMaxScaler(), num_vars),
        remainder=&#39;passthrough&#39;)

    #support_vect=svm.SVC(gamma = &#39;auto&#39;, probability=True)
    random_forest=RandomForestClassifier()

    # fit the model
    pipeline = make_pipeline(col_trans, random_forest)

    # Use GridSearch to find the best fitting model based on 10 folds
    model = GridSearchCV(pipeline, param_grid={}, cv=10)
    
    model.fit(X_train, y_train);

    # Upload trained model to a stage
    model_output_dir = &#39;/tmp&#39;
    model_file = os.path.join(model_output_dir, &#39;model.joblib&#39;)
    dump(model, model_file)

    # Let&#39;s first create a stage to store the artifacts.
    session.sql(&#39;create stage if not exists my_models&#39;).collect()
    session.file.put(model_file, &#34;@my_models&#34;, overwrite=True)

    # Return model R2 score on train and test data.
    return {&#34;R2 score on Train&#34;: model.score(X_train, y_train),&#34;R2 score on Test&#34;: model.score(X_test, y_test)}

# call the function on the client (passing in the session object and dataset) 
train_churn_prediction_model(session,&#34;TELCO_DATASET&#34;)

# returns model scores. For example,
{&#39;R2 score on Train&#39;: 0.9976, &#39;R2 score on Test&#39;: 0.9968}
</code></pre>
<p>To run this same code in the warehouse, you must first register the function as a stored procedure. Then you can simply use <code>session.call()</code> to indicate that you want to run a specific stored procedure (in this case function called <code>train_churn_prediction_model</code>) in the warehouse.</p>
<pre><code language="language-python" class="language-python"># create a stage location for the stored procedure
session.sql(&#39;create stage if not exists my_sprocs&#39;).collect()

# register the function and indicate the libraries and versions needed
session.sproc.register(
    func=train_churn_prediction_model, 
    name=&#34;train_churn_prediction_model&#34;, 
    packages=[&#39;snowflake-snowpark-python==0.7.0&#39;,&#39;scikit-learn==1.0.2&#39;,&#39;joblib&#39;], 
    is_permanent=True, 
    stage_location=&#34;@my_sprocs&#34;,
    replace=True)

# call the function server side (in the warehouse)
print(session.call(&#39;train_churn_prediction_model&#39;,&#39;TELCO_DATASET&#39;))

# returns model scores from the warehouse. For example,
{&#34;R2 score on Test&#34;: 0.99685, &#34;R2 score on Train&#34;: 0.9975625}
</code></pre>
<p>This demonstrates what makes Snowpark really shine for data scientists: take the same data science code and libraries that you use to initially develop you model, and then, without changing anything, run it directly in the warehouse—where your data live. No need to move data back and fourth (from client to server) or to change your code, languages, or interfaces.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Return predictions from the productionized model" duration="4">
        <p>You may have noticed that the <code>train_churn_prediction_model</code> also saves the model object itself to a stage in Snowflake called <code>my_models</code> . This is a key technique that makes the client-side function also work on the serve side. Importantly, now that the model object lives in the warehouse, it is essentially deployed into production; it can be accessed from within the notebook, or from any other Python environment that is connected to the warehouse (think dashboards, apps, reports, etc).</p>
<p>Methods on the model object can be called using Snowflake&#39;s <a href="https://docs.snowflake.com/en/developer-guide/udf/python/udf-python.html" target="_blank">user-defined functions</a> (UDFs). Since we want to now return predictions from our model, we will have to call the model&#39;s <code>predict()</code> method and pass it some new samples to classify. In the snippet below, we accomplish this by (1) creating a stage (location) for the UDF, (2) importing our previously created model, and (3) writing a function that will pass new data to the model&#39;s <code>.predict()</code> method.</p>
<pre><code language="language-python" class="language-python"># Let&#39;s first create a stage to store the artifacts
session.sql(&#39;create stage if not exists my_udfs&#39;).collect()
session.clear_imports()
session.clear_packages()

# Add trained model as dependency
session.add_import(&#39;@my_models/model.joblib.gz&#39;)

# UDF definition 
@udf(name=&#39;predict_churn&#39;, packages=[&#39;pandas&#39;,&#39;joblib&#39;,&#39;scikit-learn==1.0.2&#39;], is_permanent = True, stage_location = &#39;@my_udfs&#39;, replace=True, session=session)
def predict_churn(args: list) -&gt; float:

    import sys
    import pandas as pd
    from joblib import load

    IMPORT_DIRECTORY_NAME = &#34;snowflake_import_directory&#34;
    import_dir = sys._xoptions[IMPORT_DIRECTORY_NAME]

    model_file = import_dir + &#39;model.joblib.gz&#39;
    model = load(model_file)

    feature_cols=[&#39;GENDER&#39;,
        &#39;SENIORCITIZEN&#39;,
        &#39;PARTNER&#39;,
        &#39;DEPENDENTS&#39;,
        &#39;TECHSUPPORT&#39;,
        &#39;CONTRACT&#39;,
        &#39;PAPERLESSBILLING&#39;,
        &#39;MONTHLYCHARGES&#39;,
        &#39;TOTALCHARGES&#39;,
        &#39;TENUREMONTHS&#39;,
        &#39;PHONESERVICE&#39;,
        &#39;MULTIPLELINES&#39;,
        &#39;INTERNETSERVICE&#39;,
        &#39;ONLINESECURITY&#39;,
        &#39;ONLINEBACKUP&#39;,
        &#39;DEVICEPROTECTION&#39;,
        &#39;STREAMINGTV&#39;,
        &#39;STREAMINGMOVIES&#39;,
        &#39;PAYMENTMETHOD&#39;]

    row = pd.DataFrame([args], columns=feature_cols)

    return model.predict(row)
</code></pre>
<p>Finally, you can call this UDF as a part of a <code>SELECT</code> statement. For every row in that statement, the <code>predict_churn</code> UDF will be called (this is what makes the UDF a <a href="https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-introduction.html#what-is-a-python-udf" target="_blank">scalar function</a>). For example, here we take a new set of data and pass each row to our classifier. The output is a rich DataFrame with the classifications returned in the <code>PREDICTED_CHURN</code> column.</p>
<p class="image-container"><img alt="img" src="img/518f842480afdb47.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Conclusion" duration="1">
        <p>Machine learning workflows generally involves model prototyping, evaluation, and deployment. These typically require different languages, technologies, compute environments, and interfaces. When we combine Snowpark with Deepnote, we satisfy these goals without sacrificing the workflows and tools that data scientists use. Further, computation can be directed client side (in the notebook) or server side (in the warehouse)—without moving data around or changing your code. This provides seamless flexibility and power when developing machine learning workflows.</p>
<h2 is-upgraded>Related Resources</h2>
<ul>
<li><a href="https://deepnote.com/sign-up?utm_source=ML_workflows_with_snowpark_&_deepnote&utm_medium=snowpark_quickstart" target="_blank">Deepnote&#39;s data science notebook</a></li>
<li><a href="https://github.com/Snowflake-Labs/snowpark-python-demos/blob/main/README.md" target="_blank">Snowpark for Python Demos</a></li>
<li><a href="https://docs.snowflake.com/en/developer-guide/snowpark/python/index.html" target="_blank">Snowpark for Python Developer Guide</a></li>
</ul>
<h2 class="checklist" is-upgraded>What we&#39;ve covered</h2>
<p>We have built and deployed a churn detection model using Deepnote and Snowpark. We covered how to connect to Snowflake from Deepnote, and how you can use Snowpark to process data without transferring it to the notebook. In addition, we learned how Snowpark for Python can be used to training and deploy models directly in the Snowflake warehouse. These steps can be applied more generally to your other machine learning projects.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/native-shim.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/custom-elements.min.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/prettify.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>
  <script type="text/javascript">
    window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var r=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(r?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["addEventProperties","addUserProperties","clearEventProperties","identify","removeEventProperty","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
    heap.load("2025084205");
  </script>
</body>
</html>
