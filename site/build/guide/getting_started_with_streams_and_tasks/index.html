
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Getting Started with Streams &amp; Tasks</title>

  
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5Q8R2G');</script>
  

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-08H27EW14N"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-08H27EW14N');
</script>

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q8R2G"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  
  <google-codelab-analytics gaid="UA-41491190-9"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="getting_started_with_streams_and_tasks"
                  title="Getting Started with Streams &amp; Tasks"
                  environment="web"
                  feedback-link="https://github.com/Snowflake-Labs/sfguides/issues">
    
      <google-codelab-step label="Overview" duration="4">
        <p>This guide will take you through a scenario of using Snowflake&#39;s Tasks and Streams capabilities to ingest a stream of data and prepare for analytics.</p>
<p>Streams provides a change tracking mechanism for your tables and views, enabling and ensuring &#34;exactly once&#34; semantics for new or changed data.</p>
<p>Tasks are Snowflake objects to execute a single command, which could be simple SQL command or calling an extensive stored procedure.  Tasks can be scheduled or run on-demand, either within a Snowflake Virtual warehouse or serverless.</p>
<p>This Lab will also construct a Directed Acyclic Graph (DAG), which is a series of tasks composed of a single root task and additional tasks, organized by their dependencies. Tasks will be combined with table streams to create data pipelines, continuous ELT workflows to process recently received or changed table rows.</p>
<p>A simulated streaming datafeed will be used for this exercise, using a Snowpark-based Stored Procedure, to simplify your setup and focus on these two capabilities.  The simulation will be high-volume, at 1 million transactions a minute (exceeding 15k/second), of credit card purchases and returns. This prerequisite streaming ingestion was modeled to mirror one created from Snowflake&#39;s Kafka Connector, without the distraction of having to setup a running Kafka instance.<br> While not covered in this exercise, one can use these building blocks to further enrich your data with Snowflake Marketplace data, train and deploy machine learning models, perform fraud detection, and other use cases by combining these skills with other Snowflake virtual hands-on labs.</p>
<h2 is-upgraded>Prerequisites</h2>
<ul>
<li>Familiarity with Snowflake, basic SQL knowledge, Snowsight UI and Snowflake objects</li>
</ul>
<h2 class="checklist" is-upgraded>What You&#39;ll Learn</h2>
<ul class="checklist">
<li>how to create a Snowflake Stream</li>
<li>how to create and schedule a Snowflake Task</li>
<li>how to orchestrate tasks into data pipelines</li>
<li>how Snowpark can be used to build new types of user-defined functions and stored procedures</li>
<li>multiple ways to manage and monitor your Snowflake tasks and data pipelines</li>
</ul>
<h2 is-upgraded>What You&#39;ll Need</h2>
<p>To participate in the virtual hands-on lab, attendees need the following:</p>
<ul>
<li>A <a href="https://signup.snowflake.com/?lab=getStartedWithStreamsAndTasks&utm_cta=quickstart-getstartedwithstreamsandtasks-en" target="_blank">Snowflake Enterprise Account on preferred AWS region</a> with <strong>ACCOUNTADMIN</strong> access</li>
</ul>
<h2 is-upgraded>What You&#39;ll Build</h2>
<ul>
<li>A Snowflake database that contains all data and objects built in this lab</li>
<li>A Stage and Staging table to initially land your incoming data stream</li>
<li>An Analytics-Ready Table</li>
<li>A Stream to track recently-received credit card transactions</li>
<li>Tasks orchestrated two ways to process those new transactions</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Setting up Snowflake" duration="5">
        <h2 is-upgraded>Login and Setup Lab</h2>
<p>Log into your Snowflake account or <a href="https://signup.snowflake.com/?lab=getStartedWithStreamsAndTasks&utm_cta=quickstart-getstartedwithstreamsandtasks-en" target="_blank">signup for a free trial</a>. You can access the SQL commands we will execute throughout this lab directly in your Snowflake account by setting up your environment below:</p>
<p><a href="https://app.snowflake.com/resources/labs/getStartedWithStreamsAndTasks" target="_blank"><paper-button class="colored" raised>Setup Lab Environment</paper-button></a></p>
<p>This will create worksheets containing the lab SQL that can be executed as we step through this lab.</p>
<p class="image-container"><img alt="setup_lab" src="img/9257538f95272374.png"></p>
<p>Once the lab has been setup, it can be continued by revisiting the <a href="https://app.snowflake.com/resources/labs/getStartedWithStreamsAndTasks" target="_blank">lab details page</a> and clicking <code>Continue Lab</code></p>
<p class="image-container"><img alt="continue_lab" src="img/794cb1f4d1842ed6.png"></p>
<p>or by navigating to Worksheets and selecting the <code>Getting Started with Streams & Tasks</code> folder.</p>
<p class="image-container"><img alt="worksheets" src="img/9ee5a3a01be442ca.png"></p>
<h2 is-upgraded>Set your Role</h2>
<p>Finally, switch to the ACCOUNTADMIN role.  If you just created an evaluation account to go through this Lab, this should be easy.  However, if you are using an established account and find this role missing from your list, you may need assistance to complete the next few steps.  Creating a Role, Database, Stages, Tasks, and monitoring tasks executed by ‘System&#39; requires higher-level permissions.<br><img src="img/a88d36b219450e17.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Begin Construction" duration="5">
        <p>Create Foundational Snowflake Objects for this Hands-on Lab</p>
<h2 is-upgraded>a)  Create a new role for this Lab and grant permissions</h2>
<pre><code>use role ACCOUNTADMIN;
set myname = current_user();
create role if not exists VHOL;
grant role VHOL to user identifier($myname);
grant create database on account to role VHOL;
grant EXECUTE TASK, EXECUTE MANAGED TASK on ACCOUNT to role VHOL;
grant IMPORTED PRIVILEGES on DATABASE SNOWFLAKE to role VHOL;
</code></pre>
<h2 is-upgraded>b)  Create a Dedicated Virtual Compute Warehouse</h2>
<p>Size XS, dedicated for this Hands-on Lab</p>
<pre><code>create or replace warehouse VHOL_WH WAREHOUSE_SIZE = XSMALL, AUTO_SUSPEND = 5, AUTO_RESUME= TRUE;
grant all privileges on warehouse VHOL_WH to role VHOL;
</code></pre>
<h2 is-upgraded>c)  Create Database used throughout this Lab</h2>
<pre><code>use role VHOL;
create or replace database VHOL_ST;
grant all privileges on database VHOL_ST to role VHOL;
use database VHOL_ST;
use schema PUBLIC;
use warehouse VHOL_WH;
</code></pre>
<h2 is-upgraded>d)  Create an internal Stage</h2>
<p>Dedicated for incoming streaming files (Typically real-time stream consumption would be automated from Kafka using Snowflake Kafka Connector, but for this exercise we are simulating data and focusing on Task and Stream usage.).  Incoming data will JSON format, with many transactions within each file.</p>
<pre><code>create or replace stage VHOL_STAGE
FILE_FORMAT = ( TYPE=JSON,STRIP_OUTER_ARRAY=TRUE );
</code></pre>
<h2 is-upgraded>d)  Create a Staging/Landing Table</h2>
<p>Where all incoming data will land initially.  Each row will contain a transaction, but JSON will be stored as a VARIANT datatype within Snowflake.</p>
<pre><code>create or replace table CC_TRANS_STAGING (RECORD_CONTENT variant);
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Simulated Stream Source" duration="1">
        <p>Create Simulation Data Generation Stored Procedure (Using Snowpark Java).  We kept this as a separate step, as it is necessary for setup, but deep interrogation of how this Stored Procedure works to use Snowflake as a streaming ingestion process is not the focus of this Lab. Just copy, paste and run this to create the Stored Procedure:</p>
<pre><code>create or replace procedure SIMULATE_KAFKA_STREAM(mystage STRING,prefix STRING,numlines INTEGER)
  RETURNS STRING
  LANGUAGE JAVA
  PACKAGES = (&#39;com.snowflake:snowpark:latest&#39;)
  HANDLER = &#39;StreamDemo.run&#39;
  AS
  $$
    import com.snowflake.snowpark_java.Session;
    import java.io.*;
    import java.util.HashMap;
    public class StreamDemo {
      public String run(Session session, String mystage,String prefix,int numlines) {
        SampleData SD=new SampleData();
        BufferedWriter bw = null;
        File f=null;
        try {
            f = File.createTempFile(prefix, &#34;.json&#34;);
            FileWriter fw = new FileWriter(f);
	        bw = new BufferedWriter(fw);
            boolean first=true;
            bw.write(&#34;[&#34;);
            for(int i=1;i&lt;=numlines;i++){
                if (first) first = false;
                else {bw.write(&#34;,&#34;);bw.newLine();}
                bw.write(SD.getDataLine(i));
            }
            bw.write(&#34;]&#34;);
            bw.close();
            return session.file().put(f.getAbsolutePath(),mystage,options)[0].getStatus();
        }
        catch (Exception ex){
            return ex.getMessage();
        }
        finally {
            try{
	            if(bw!=null) bw.close();
                if(f!=null &amp;&amp; f.exists()) f.delete();
	        }
            catch(Exception ex){
	            return (&#34;Error in closing:  &#34;+ex);
	        }
        }
      }
      
      private static final HashMap&lt;String,String&gt; options = new HashMap&lt;String, String&gt;() {
        { put(&#34;AUTO_COMPRESS&#34;, &#34;TRUE&#34;); }
      };
      
      // sample data generator (credit card transactions)
    public static class SampleData {
      private static final java.util.Random R=new java.util.Random();
      private static final java.text.NumberFormat NF_AMT = java.text.NumberFormat.getInstance();
      String[] transactionType={&#34;PURCHASE&#34;,&#34;PURCHASE&#34;,&#34;PURCHASE&#34;,&#34;PURCHASE&#34;,&#34;PURCHASE&#34;,&#34;PURCHASE&#34;,&#34;PURCHASE&#34;,&#34;PURCHASE&#34;,&#34;PURCHASE&#34;,&#34;PURCHASE&#34;,&#34;REFUND&#34;};
      String[] approved={&#34;true&#34;,&#34;true&#34;,&#34;true&#34;,&#34;true&#34;,&#34;true&#34;,&#34;true&#34;,&#34;true&#34;,&#34;true&#34;,&#34;true&#34;,&#34;true&#34;,&#34;false&#34;};
      static {
        NF_AMT.setMinimumFractionDigits(2);
        NF_AMT.setMaximumFractionDigits(2);
        NF_AMT.setGroupingUsed(false);
      }
      
      private static int randomQty(int low, int high){
        return R.nextInt(high-low) + low;
      }
      
      private static double randomAmount(int low, int high){
        return R.nextDouble()*(high-low) + low;
      }
      
      private String getDataLine(int rownum){
        StringBuilder sb = new StringBuilder()
            .append(&#34;{&#34;)
            .append(&#34;\&#34;element\&#34;:&#34;+rownum+&#34;,&#34;)
            .append(&#34;\&#34;object\&#34;:\&#34;basic-card\&#34;,&#34;)
            .append(&#34;\&#34;transaction\&#34;:{&#34;)
            .append(&#34;\&#34;id\&#34;:&#34;+(1000000000 + R.nextInt(900000000))+&#34;,&#34;)
            .append(&#34;\&#34;type\&#34;:&#34;+&#34;\&#34;&#34;+transactionType[R.nextInt(transactionType.length)]+&#34;\&#34;,&#34;)
            .append(&#34;\&#34;amount\&#34;:&#34;+NF_AMT.format(randomAmount(1,5000)) +&#34;,&#34;)
            .append(&#34;\&#34;currency\&#34;:&#34;+&#34;\&#34;USD\&#34;,&#34;)
            .append(&#34;\&#34;timestamp\&#34;:\&#34;&#34;+java.time.Instant.now()+&#34;\&#34;,&#34;)
            .append(&#34;\&#34;approved\&#34;:&#34;+approved[R.nextInt(approved.length)]+&#34;&#34;)
            .append(&#34;},&#34;)
            .append(&#34;\&#34;card\&#34;:{&#34;)
                .append(&#34;\&#34;number\&#34;:&#34;+ java.lang.Math.abs(R.nextLong()) +&#34;&#34;)
            .append(&#34;},&#34;)
            .append(&#34;\&#34;merchant\&#34;:{&#34;)
            .append(&#34;\&#34;id\&#34;:&#34;+(100000000 + R.nextInt(90000000))+&#34;&#34;)
            .append(&#34;}&#34;)
            .append(&#34;}&#34;);
        return sb.toString();
      }
    }
}
$$;
</code></pre>
<p>Which will return: <img src="img/673e6ee23b93f8ab.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Develop and Testing" duration="15">
        <h2 is-upgraded>a)  Call SP to generate the compressed JSON load file</h2>
<p>Later, this will be setup to run repetitively on a schedule to simulate a real-time stream ingestion process.  First, we run the stored procedure on-demand using:</p>
<pre><code>call SIMULATE_KAFKA_STREAM(&#39;@VHOL_STAGE&#39;,&#39;SNOW_&#39;,1000000);
</code></pre>
<p>Which returns:<br><img src="img/7453ad8e32a5cc02.png"></p>
<h2 is-upgraded>b)  Verify file was created in the internal stage</h2>
<pre><code>list @VHOL_STAGE PATTERN=&#39;.*SNOW_.*&#39;;
</code></pre>
<p>This file looks similar to this in your Stage: <img src="img/4ac7eacb24fc2433.png"></p>
<h2 is-upgraded>c)  Load file into Staging Table  (about 100Mb raw json data per file).  Later, this will be setup to run every x minutes.</h2>
<pre><code>copy into CC_TRANS_STAGING from @VHOL_STAGE PATTERN=&#39;.*SNOW_.*&#39;;
</code></pre>
<p>Which will return this: <img src="img/e963398adcae8d0e.png"></p>
<h2 is-upgraded>d)  Now, there should be raw source JSON data in our Landing/Staging Table, but now a VARIANT datatype.</h2>
<pre><code>select count(*) from CC_TRANS_STAGING;
select * from CC_TRANS_STAGING limit 10;
</code></pre>
<p>Select one of the rows, and you will see a better view of the contents, which will be similar to: <img src="img/f5204e78e77da1ec.png"></p>
<h2 is-upgraded>e) Run Test Queries.  Now that it is a VARIANT datatype, the contents of the JSON is now understood.</h2>
<pre><code>select RECORD_CONTENT:card:number as card_id from CC_TRANS_STAGING limit 10;
</code></pre>
<pre><code>select
RECORD_CONTENT:card:number::varchar,
RECORD_CONTENT:merchant:id::varchar,
RECORD_CONTENT:transaction:id::varchar,
RECORD_CONTENT:transaction:amount::float,
RECORD_CONTENT:transaction:currency::varchar,
RECORD_CONTENT:transaction:approved::boolean,
RECORD_CONTENT:transaction:type::varchar,
RECORD_CONTENT:transaction:timestamp::datetime
from CC_TRANS_STAGING
where RECORD_CONTENT:transaction:amount::float &lt; 600 limit 10;
</code></pre>
<p>While the raw data was JSON, Snowflake has converted that during the COPY INTO step, creating VARIANT column values, making semi-structured data much easier <img src="img/f8f60bc448ee4706.png"></p>
<h2 is-upgraded>f)  Create a View of Staging Table for real-time operational queries (normalize VARIANT column to a full tabular representation)</h2>
<pre><code>create or replace view CC_TRANS_STAGING_VIEW (card_id, merchant_id, transaction_id, amount, currency, approved, type, timestamp ) as (
select
RECORD_CONTENT:card:number::varchar card_id,
RECORD_CONTENT:merchant:id::varchar merchant_id,
RECORD_CONTENT:transaction:id::varchar transaction_id,
RECORD_CONTENT:transaction:amount::float amount,
RECORD_CONTENT:transaction:currency::varchar currency,
RECORD_CONTENT:transaction:approved::boolean approved,
RECORD_CONTENT:transaction:type::varchar type,
RECORD_CONTENT:transaction:timestamp::datetime timestamp
from CC_TRANS_STAGING);
</code></pre>
<h2 is-upgraded>g) We will be creating a stream, so we need to enable change tracking</h2>
<pre><code>alter table CC_TRANS_STAGING set CHANGE_TRACKING = true;
alter view CC_TRANS_STAGING_VIEW set CHANGE_TRACKING = true;
</code></pre>
<h2 is-upgraded>h) Preview your View</h2>
<pre><code>select * from CC_TRANS_STAGING_VIEW limit 10;
select count(*) from CC_TRANS_STAGING_VIEW limit 10;
</code></pre>
<p>While data in staging table is JSON, one can now see traditional tablular view of the data</p>
<h2 is-upgraded>i) Create a Stream on the operational view</h2>
<p>Note:  While we could put a stream on the staging table, by using the view one can use the normalized view</p>
<pre><code>create or replace stream CC_TRANS_STAGING_VIEW_STREAM on view CC_TRANS_STAGING_VIEW SHOW_INITIAL_ROWS=true;
select count(*) from CC_TRANS_STAGING_VIEW_STREAM;
select * from CC_TRANS_STAGING_VIEW_STREAM limit 10;
</code></pre>
<p>Note:  We are populating the Stream with the all current rows in the table.  Querying the Stream does not consume it.  But, something that is in a transaction (auto or manual committed) will consume the records in the stream for exactly-once change pattern.</p>
<h2 is-upgraded>j) Create Analytical table (normalized) for transformation (ELT) and easier user consumption (Staging table for landing can then be purged after X days)</h2>
<pre><code>create or replace table CC_TRANS_ALL (
card_id varchar,
merchant_id varchar,
transaction_id varchar,
amount float,
currency varchar,
approved boolean,
type varchar,
timestamp datetime);
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Create Data Pipeline #1" duration="15">
        <p>Create Tasks to orchestrate Processing for this Hands-on Lab.  Each Task will be independent and separately scheduled.</p>
<p>See diagram: <img src="img/b4c76654b9e37ed0.png"></p>
<ul>
<li>First task will create an incoming JSON file containing credit card transactions and store this file in the Stage.</li>
<li>Second task will perform a COPY INTO operation, reading file(s) within the Stage and load into staging/landing table</li>
<li>Third task will perform an ELT transformation operation, processing recently-added records to the staging/landing table and load into the &#34;analytics-ready&#34; table.</li>
</ul>
<h2 is-upgraded>a)  Create Task</h2>
<p>Task be our real-time kafka streaming source (calling Stored Procedure to simulate incoming Kafka-provided credit card transactions).  This task will be scheduled to run every 60 seconds, very similar to how Snowflake&#39;s Kafka Connector bundles and ingests data.</p>
<pre><code>create or replace task GENERATE_TASK
WAREHOUSE=VHOL_WH
SCHEDULE = &#39;1 minute&#39;
COMMENT = &#39;Generates simulated real-time data for ingestion&#39;
as
call SIMULATE_KAFKA_STREAM(&#39;@VHOL_STAGE&#39;,&#39;SNOW_&#39;,1000000);
</code></pre>
<h2 is-upgraded>b)  View Definition of Task</h2>
<p>Here are the details of your newly-created Task</p>
<pre><code>describe task GENERATE_TASK;
</code></pre>
<h2 is-upgraded>c)  Manually Run Task</h2>
<pre><code>execute task GENERATE_TASK;
</code></pre>
<h2 is-upgraded>d) Monitor our Activities</h2>
<ul>
<li>Right-Click on &#34;House icon&#34; at upper right and open in a new browser tab:<br><img src="img/ed1962ecee5eb3e2.png"></li>
<li>and then<br><img src="img/1d5848bca6da144d.png"></li>
<li>From that new tab, select Activity&#34; on the left menu, then &#34;Query History&#34;:<br><img src="img/71acf7db1d100d92.png"></li>
<li>Remove filters at the top of this table, including your username, as later scheduled tasks will run as &#34;System&#34;: <img src="img/7c3c7f9b6d6e23ad.png"></li>
<li>Click &#34;Filter&#34;, and add filter option ‘Queries executed by user tasks&#39; and click &#34;Apply Filters&#34;: <img src="img/445b67a969de9a0d.png"></li>
<li>Now, you can see all executed SQL commands, including those executed by your running tasks: <img src="img/91ecff3a7b531913.png"></li>
</ul>
<p>If you don&#39;t see your tasks, make sure you are ACCOUNTADMIN in this tab/window too (or same role if not ACCOUNTADMIN but have rights to see SYSTEM-executed tasks). Finally, click on your Worksheet tab leaving your Query History tab available as you will want to return and jump between these two Snowsight views.</p>
<h2 is-upgraded>e)  Enable Task to Run on its Schedule</h2>
<p>Task scheduled to run every 1 minute</p>
<pre><code>alter task GENERATE_TASK RESUME;
</code></pre>
<h2 is-upgraded>f)  List Files in Stage</h2>
<p>List Files in Stage now ready to be copied into Snowflake. NOTE:  Task will not run instantly, it will wait a minute before running</p>
<pre><code>list @VHOL_STAGE PATTERN=&#39;.*SNOW_.*&#39;;
</code></pre>
<h2 is-upgraded>g)  Wait</h2>
<p>Wait a couple minutes and then you should see that the Task is regularly generating and adding a new file to the Stage. Reminder:  Remember to turn these Tasks off at end of lab or, if you take a break, jump to the last step of this section for the commands to suspend your tasks.</p>
<pre><code>list @VHOL_STAGE PATTERN=&#39;.*SNOW_.*&#39;;
</code></pre>
<h2 is-upgraded>h)  Create a Second Task</h2>
<p>This Task will run every 3 minutes and utilizes the Staging Stream that identifies newly added records to the Staging file and loads into our analytical table.  As there will be multiple files ready for ingestion, note each will be loaded independently and in parallel.</p>
<p>For this Task, we will utilize the option to run with a serverless compute, as a full compute warehouse is not really necessary to have running for these small continuous micro-batch tasks.  In an actual implementation, the incoming simulated data stream will be external.</p>
<pre><code>create or replace task PROCESS_FILES_TASK
USER_TASK_MANAGED_INITIAL_WAREHOUSE_SIZE = &#39;XSMALL&#39;
SCHEDULE = &#39;3 minute&#39;
COMMENT = &#39;Ingests Incoming Staging Datafiles into Staging Table&#39;
as
copy into CC_TRANS_STAGING from @VHOL_STAGE PATTERN=&#39;.*SNOW_.*&#39;;
</code></pre>
<p>Note:  Snowflake does track what files in a stage it has already processed for a period of time, but, if you get thousands and thousands of files in your stage, you don&#39;t want this process to sort through them for each run of the Task. Using &#34;PURGE&#34; is a way to delete them during the COPY INTO step, or you can create a separate step to archive or delete these files on your preferred schedule.</p>
<h2 is-upgraded>i)  Check Staging Table, View, and Stream</h2>
<p>Query Staging Table and its Stream tracking changes, before running Process Task.  Note before and after row counts.</p>
<pre><code>select count(*) from CC_TRANS_STAGING;
select * from CC_TRANS_STAGING limit 10;
select count(*) from CC_TRANS_STAGING_VIEW_STREAM;
select * from CC_TRANS_STAGING_VIEW_STREAM limit 10;
</code></pre>
<h2 is-upgraded>j)  Execute Task Manually</h2>
<pre><code>execute task PROCESS_FILES_TASK;
</code></pre>
<p>Wait here for processing (Can monitor from your Query History tab)</p>
<h2 is-upgraded>k)  Query Staging View and its Stream</h2>
<p>Streams make it so easy to track changes, after running Process Task:</p>
<pre><code>select count(*) from CC_TRANS_STAGING_VIEW;
select count(*) from CC_TRANS_STAGING_VIEW_STREAM;
</code></pre>
<h2 is-upgraded>l)  Begin task to run on its schedule</h2>
<pre><code>alter task PROCESS_FILES_TASK resume;
</code></pre>
<h2 is-upgraded>m)  Create Third Task</h2>
<p>This task will run every 4 minutes, leveraging the Staging Stream to process new records and load into the Analytical Table. Note that this first checks if there are records in the stream and then will process and load records if the stream has records.</p>
<pre><code>create or replace task REFINE_TASK
USER_TASK_MANAGED_INITIAL_WAREHOUSE_SIZE = &#39;XSMALL&#39;
SCHEDULE = &#39;4 minute&#39;
COMMENT = &#39;2.  ELT Process New Transactions in Landing/Staging Table into a more Normalized/Refined Table (flattens JSON payloads)&#39;
when
SYSTEM$STREAM_HAS_DATA(&#39;CC_TRANS_STAGING_VIEW_STREAM&#39;)
as
insert into CC_TRANS_ALL (select                     
card_id, merchant_id, transaction_id, amount, currency, approved, type, timestamp
from CC_TRANS_STAGING_VIEW_STREAM);
</code></pre>
<p>Staging tables are typically periodically purged.  This Table will be permanent, storing all transactions for their useful lifecycle.  This ELT process would also typically include more transformations, validations, and refine/enrichment however that is not the focus of this hands-on Lab.</p>
<h2 is-upgraded>n)  Query Analytical Table</h2>
<p>You should see there are no records in this empty table</p>
<pre><code>select count(*) from CC_TRANS_ALL;
</code></pre>
<h2 is-upgraded>o)  Query Staging Table&#39;s Stream</h2>
<p>Stream is showing there are records and has not yet been flushed/consumed.</p>
<pre><code>select count(*) from CC_TRANS_STAGING_VIEW_STREAM;
</code></pre>
<h2 is-upgraded>p)  Run Task Manually</h2>
<pre><code>execute task REFINE_TASK;
</code></pre>
<p>Wait here for task to complete, check Query History view to monitor.</p>
<h2 is-upgraded>q)  Query Staging Table&#39;s Stream</h2>
<p>Stream now showing stream after it has been flushed/consumed</p>
<pre><code>select count(*) from CC_TRANS_ALL;
select count(*) from CC_TRANS_STAGING_VIEW_STREAM;
</code></pre>
<p>Note: The Stream will first show just the initial records (1,000,000).  Once those are consumed for the initial rows, then the stream will show the rows added by the scheduled tasks.</p>
<h2 is-upgraded>r)  Schedule Task</h2>
<p>Resume Task so it will run on its schedule.  Note it is fully independent of the other tasks we have running.  You can also configure tasks to run at a certain time, using CRON-based syntax option.</p>
<pre><code>alter task REFINE_TASK resume;
</code></pre>
<h2 is-upgraded>s)  Reporting</h2>
<p>One can report on LOAD metadata generated by Snowflake.  This is available in two views:</p>
<ol type="1">
<li>For no latency, but only 14 days of retention:</li>
</ol>
<pre><code>select * from VHOL_ST.INFORMATION_SCHEMA.LOAD_HISTORY where SCHEMA_NAME=current_schema() and TABLE_NAME=&#39;CC_TRANS_STAGING&#39;;
</code></pre>
<ol type="1" start="2">
<li>Up to 90 minutes latency with this view, but 365 days of retention:</li>
</ol>
<pre><code>select * from SNOWFLAKE.ACCOUNT_USAGE.LOAD_HISTORY where SCHEMA_NAME=current_schema() and TABLE_NAME=&#39;CC_TRANS_STAGING&#39;;
</code></pre>
<h2 is-upgraded>t)  Stop Tasks</h2>
<pre><code>alter task REFINE_TASK SUSPEND;
alter task PROCESS_FILES_TASK SUSPEND;
alter task GENERATE_TASK SUSPEND;
</code></pre>
<h2 is-upgraded>u)  See how many transactions we have fully processed so far</h2>
<pre><code>select count(*) from CC_TRANS_ALL;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Create Data Pipeline #2" duration="15">
        <p>This section&#39;s Data Pipeline will be very similar to the first, except will orchestrate tasks with dependencies, rather than being independently scheduled and executed.</p>
<p>See diagram: <img src="img/f46c7992b697a11c.png"></p>
<h2 is-upgraded>a)  Create Two Tasks</h2>
<p>Similar to the tasks created in the previous section, but ones that will become subtasks (rather than independent scheduling). Note: Define all of these to run within the same warehouse, but that is not a requirement.</p>
<ul>
<li>First Task</li>
</ul>
<pre><code>create or replace task REFINE_TASK2
WAREHOUSE=VHOL_WH
as
insert into CC_TRANS_ALL (select                     
card_id, merchant_id, transaction_id, amount, currency, approved, type, timestamp
from CC_TRANS_STAGING_VIEW_STREAM);
</code></pre>
<ul>
<li>Second Task</li>
</ul>
<pre><code>create or replace task PROCESS_FILES_TASK2
WAREHOUSE=VHOL_WH
as
copy into CC_TRANS_STAGING from @VHOL_STAGE PATTERN=&#39;.*SNOW_.*&#39;;
</code></pre>
<h2 is-upgraded>b)  Create Root Task</h2>
<p>This is the Task where all others will be subprocesses of.</p>
<pre><code>create or replace task LOAD_TASK
WAREHOUSE=VHOL_WH
SCHEDULE = &#39;1 minute&#39;
COMMENT = &#39;Full Sequential Orchestration&#39;
as
call SIMULATE_KAFKA_STREAM(&#39;@VHOL_STAGE&#39;,&#39;SNOW_&#39;,1000000);
</code></pre>
<h2 is-upgraded>c)  First Predecessor</h2>
<p>-Have task REFINE_TASK2 be a predecessor of PROCESS_FILES_TASK2</p>
<pre><code>alter task REFINE_TASK2 add after PROCESS_FILES_TASK2;
alter task REFINE_TASK2 RESUME;
</code></pre>
<p>-Have task LOAD_TASK be a predecessor of PROCESS_FILES_TASK2</p>
<pre><code>alter task PROCESS_FILES_TASK2 add after LOAD_TASK;
alter task PROCESS_FILES_TASK2 RESUME;
</code></pre>
<p>Note:  One can also use the ‘after&#39; within the create task command</p>
<h2 is-upgraded>d)  View DAG Orchestration</h2>
<ul>
<li>In a new tab (use right-click on &#34;home icon&#34; at upper left), Navigate in Snowsight to:<br><strong>Data&gt;Databases&gt;VHOL_ST&gt;PUBLIC&gt;Tasks&gt;LOAD_TASK</strong></li>
<li>Review &#34;Task Details&#34; tab:<br><img src="img/c0223cecf178bd5b.png"></li>
<li>Review &#34;Graph&#34; to see graphical representation of our simple flow:<br><img src="img/7f982595f5686e91.png"> Remember your warehouse is ‘VHOL_WH&#39;</li>
<li>Review &#34;Run History&#34; to view Task Executions:<br><img src="img/eb189dfc4f2c01c6.png"></li>
</ul>
<p>Note:  Graph and Task History are recently added previews, so may need to ask on how to enable in your account if these menu options are missing.</p>
<h2 is-upgraded>e)  Start LOAD Task</h2>
<pre><code>alter task LOAD_TASK RESUME;
</code></pre>
<p>Wait, as task will run after one minute.  Then, see a file created in Stage</p>
<pre><code>list @VHOL_STAGE PATTERN=&#39;.*SNOW_.*&#39;;
</code></pre>
<p>Go back to Activity tab, reviewing Query History and Task&#39;s Run History (refresh)</p>
<h2 is-upgraded>f)  Tasks in Parallel</h2>
<p>Tasks do not have to be sequential, they can also run in parallel.  Let&#39;s create a simple task to demonstrate this.  To add to the root task @ creation, you have to first suspend:</p>
<pre><code>alter task LOAD_TASK SUSPEND;
create or replace task WAIT_TASK
  WAREHOUSE=VHOL_WH
  after PROCESS_FILES_TASK2
as
  call SYSTEM$wait(1);
</code></pre>
<h2 is-upgraded>g)  Run Load Task</h2>
<p>After this addition, resume/enable both tasks. Note we utilized the &#34;AFTER&#34; option during creation rather than using &#34;ALTER&#34; afterward to create this dependency to the DAG process.</p>
<pre><code>alter task WAIT_TASK RESUME;
alter task LOAD_TASK RESUME;
</code></pre>
<h2 is-upgraded>h)  Monitor</h2>
<p>Go back to your Task tab, refreshing your Graph view and task&#39;s Run History.</p>
<h2 is-upgraded>i)  Task Dependencies</h2>
<p>Can also see task dependencies via SQL.  As this is available via query, this can be collected for your data catalog and other analysis/reporting purposes.</p>
<pre><code>select * from table(information_schema.task_dependents(task_name =&gt; &#39;LOAD_TASK&#39;, recursive =&gt; true));
</code></pre>
<h2 is-upgraded>j)  Section is Complete</h2>
<p>Suspend your Tasks for this Section</p>
<pre><code>alter task LOAD_TASK SUSPEND;
alter task REFINE_TASK2 SUSPEND;
alter task PROCESS_FILES_TASK2 SUSPEND;
alter task WAIT_TASK SUSPEND;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Final Steps &amp; Cleanup" duration="2">
        <h2 is-upgraded>a)  See how many transactions we have processed</h2>
<pre><code>select count(*) from CC_TRANS_ALL;
</code></pre>
<h2 is-upgraded>b)  Look at our newest record now in your Analytical table:</h2>
<pre><code>select * from CC_TRANS_ALL order by TIMESTAMP desc limit 1;
</code></pre>
<h2 is-upgraded>c)  See all tasks we have created, and to confirm their state is all &#34;Suspended&#34;</h2>
<pre><code>show tasks;
</code></pre>
<p>(suspend any still running)</p>
<h2 is-upgraded>d)    Drop Database, removing all objects created by this Hands-on Lab (Optional)</h2>
<pre><code>drop database VHOL_ST;
</code></pre>
<h2 is-upgraded>e)    Drop Warehouse (Optional)</h2>
<pre><code>use role ACCOUNTADMIN;
drop warehouse VHOL_WH;
</code></pre>
<h2 is-upgraded>e)    Drop Role (Optional)</h2>
<pre><code>use role ACCOUNTADMIN;
drop role VHOL;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Conclusion" duration="3">
        <p>Congratulations, you have completed this Lab!</p>
<h2 is-upgraded>What We Covered</h2>
<ul>
<li>Created a Snowflake Stream</li>
<li>Created and Scheduled a Snowflake Task</li>
<li>Assembled tasks into Data Pipelines</li>
<li>Snowpark can be used to build new types of user-defined functions and stored procedures</li>
<li>Managed and Monitored your Snowflake Tasks and Data Pipelines</li>
</ul>
<h2 is-upgraded>Related Resources</h2>
<ul>
<li><a href="https://docs.snowflake.com/en/user-guide/streams-intro.html" target="_blank">Streams</a></li>
<li><a href="https://docs.snowflake.com/en/user-guide/tasks-intro.html" target="_blank">Tasks</a></li>
<li><a href="https://docs.snowflake.com/en/sql-reference/sql/execute-task.html" target="_blank">Execute Tasks</a></li>
<li><a href="https://docs.snowflake.com/en/user-guide/tasks-errors.html" target="_blank">Handling Task Errors</a></li>
<li><a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe.html" target="_blank">Snowpipe</a></li>
<li><a href="https://docs.snowflake.com/en/user-guide/kafka-connector.html" target="_blank">Kafka Connector</a></li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/native-shim.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/custom-elements.min.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/prettify.js"></script>
  <script src="https://quickstarts.snowflake.com/elements/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>
  <script type="text/javascript">
    window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var r=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(r?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["addEventProperties","addUserProperties","clearEventProperties","identify","removeEventProperty","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
    heap.load("2025084205");
  </script>
</body>
</html>
